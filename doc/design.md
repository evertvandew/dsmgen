





# Hierarchical Model

Entities in the hierarchical model can have a parent. This determines the position of the entity in the model.
Entities can also have an order number, which defines the order of the entities with the same parent.
Lower order number comes first.


# Representation of the hierarchical model in diagrams

Elements from the hierarchical model can be represented in diagrams. 
A representation can also have a parent, which is always another representation. This is used for ports belonging to
the block, and for inner blocks within a composite block.

Representations contain the database ID of the diagram they belong to. This means blocks can have representations in
multiple diagrams.

Each representation has a field `logical_class` that holds the type of the model entity represented by this particular
representation. It is set during construction of the instance.



# Use of the specification
The model specification defines:

* The different elements with which a model is constructed.
* The data fields that are associated with each element in the model.
* The use of each model element, both in the hierachical model and in the diagrams.
* How certain events are handled. For instance, if an entity from the hierarchical model is dropped in a diagram,
  the default action is to create a direct representation of that entity. All representations of the entity share
  the same underlying data. But in some cases, another action must
  be taken, like creating an _instance_ of that entity that is independent from other instances, e.g. that has 
  its own set of user-edited parameters.
* Default rendering details for each element. These can be overridden by the editor of the diagram for visual purposes.
* Which elements can be connected to other elements, and how.
* Which elements can be placed in each type of diagram.
* The initial / minimal contents of the database. The explorer does not allow modifying root elements,
  so without initial contents the model can not be filled.
* Invariant rules that safeguard model integrity.

To achieve the various functions, code is generated from the specification:

* A database model is created for persisting data on the server side. This model can also instantiate the database.
* A server is created that handles REST calls from the client. It also implements the Invariant rules and
  implements two queries to serve the hierachy explorer and the diagram editor with all data they need.
* A client HTML page is generated, that gives each tool its own identity.
* A client source code file is generated, the configures the client. This client source code interacts heavily
  with the diagramming library. The diagramming library is not generated by the tool, it has been coded together.

# Storage of different parts of the model

## Blocks and Relationships
Each relationship points to two "blocks", source and target / start and finish. 
This is true for the navigational model, and for any graphical representations of those relationships.

In a diagram, each element that is represented has a "Representation Object".
There can be an infinte number of representations of a modeled entity.
Each representation has a pointer to the model entity it represents, and it has a pointer to the diagram it is in.


@startuml

package model {
  object Relation
  object BlockA
  object BlockB
  Relation --> BlockA : source
  Relation --> BlockB : target
}
package diagram {
  object RelationRepr
  object BlockARepr
  object BlockBRepr
  object Diagram
  RelationRepr --> BlockARepr : source
  RelationRepr --> BlockBRepr : target
  BlockARepr --> Diagram : diagram
  
}

BlockARepr ..> BlockA : block
BlockBRepr ..> BlockB : block
RelationRepr ..> Relation : relationship

@enduml

## Ports

Ports belong to a block, but they are in themselves blocks. This means they can be navigated in the explorer,
and relationships can connect to them without any other actions. A block can have an unlimited amount of ports.

Ports refer to their block using the `parent` fields. In regular blocks, the `parent` field is `None`.

Because Ports are treated as Blocks logically, so relationships can be made with it, the link from a Port Representation
to the underlying Port model entity is still called `block`.

@startuml

package model {
  object Port1
  object Port2
  object Block
  Port1 --> Block : parent
  Port2 --> Block : parent
}

package diagram {
  object PortRepr1
  object PortRepr2
  object BlockRepr
  PortRepr1 ..> Port1 : block
  PortRepr1 ..> Port2 : block
  PortRepr1 --> BlockRepr : parent
  PortRepr2 --> BlockRepr : parent
  BlockRepr ..> Block : block
  
}

@enduml

## Instances

In some models, a definition that is made elsewhere can be instantiated in a different model.
Examples are e.g. a block-based programming environment, like "Simulink" sold by Matlab or the `block_programming`
demo in this project.

To be useful, such definition should allow parameters to be set that configure it. For example, you can make a
definition of a PID controller, but you should be able to set the P, I and D factors independently of the definition.
The data for the parameters are stored in the Instance model entity.
This means that instances should normally not be re-used between diagrams, as then they would share parameters.
The tool enforces this by not allowing Instances to be dragged-and-dropped onto them, or created from scratch.
Instance objects are created in a diagram by dragging a definition into a diagram.
Instance objects can be browsed in the model explorer, e.g. to set their parameters.

This is supported as follows: model entities that are defined as Instances have an additional field `definition`.
At the moment, all Block model entities have that field in their datamodel, it is set to `None` for non-instances.
The `parent` field is used to specify the location of both Definition and Instance in the model hierarchy.

Representation don't know about being an instance. (though as a convenience, when retrieving a diagram, instance
representations have the definition pointed to through their `_definition` field).
There is a difference in that the representations of ports belonging to an instance, look for ports on the
definition side, not on the instance side. An instance can not have different ports than the definition.
Perhaps we will let the model structure determine is the ports can be determined by the instance, for
example to achieve blocks with a configurable number of inputs.

@startuml

package model {
  object Library
  object BlockProgram
  object Port
  object BlockRepr
  object PortRepr
  Library <-- Definition : parent
  BlockProgram <-- Instance : parent
  Definition <-- Port : parent
  object Definition {
    parameter_definition
  }
  object Instance {
    parameter_values
  }
  Definition <-- Instance : definition
  Port <.. PortRepr : block
  Instance <.. BlockRepr : block
  BlockRepr <-- PortRepr : parent
}
@enduml

## Recursive blocks

It is possible to model hierarchy directly using diagrams. This can be done in two ways" in-diagram and outside the
diagram. In-diagram hierarchy is where blocks are placed within blocks, outside the diagram is where a block
represents another diagram.

In the case of in-diagram recursing, the representation of blocks within another block, point to the outer block
with the `parent` field. In case where blocks are diagrams, the tools knows that the block is also a diagram.
Representations within that inner diagram use the regular `diagram` construct to indicate the relationship,
`parent` is normally `None`.

With outside recursion, there is the question how to represent connections to the outside world.
In some diagrams, communication goes through ports. The ports of the diagram-block must be represented as blocks in the
inner diagram. This is done using the PortLabel block, a hard-coded type for this purpose.

@startuml

object DiagramBlock
object OuterBlock
object InnerBlock1
object InnerBlock2
object Relation

OuterBlock <-- InnerBlock1 : parent
OuterBlock <-- InnerBlock2 : parent
Relation --> InnerBlock1 : source
Relation --> InnerBlock2 : target

@enduml

@startuml

package model {
  object DiagramBlock
  object Port
  object InnerBlock
  Port --> DiagramBlock : parent
  DiagramBlock <-- InnerBlock : parent
}
package outer_diagram {
  object DiagramBlockRepr
  object PortRepr
  Port <.. PortRepr : block
  DiagramBlock <.. DiagramBlockRepr : block
  DiagramBlockRepr <-- PortRepr : parent
}
package inner_diagram {
  object PortLabel
  object InnerBlockRepr
  object RelationRepr
  Port <.. PortLabel : block
  PortLabel --> RelationRepr : source
  RelationRepr --> InnerBlockRepr : target
  InnerBlock <.. InnerBlockRepr : block
}

@enduml

# Design choices
* For now, CompoundEntities only have BlockDiagram inner diagrams, not laned diagrams.

