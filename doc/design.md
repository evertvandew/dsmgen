





# Hierarchical Model

Entities in the hierarchical model can have a parent. This determines the position of the entity in the model.
Entities can also have an order number, which defines the order of the entities with the same parent.
Lower order number comes first.


# Representation of the hierarchical model in diagrams

Elements from the hierarchical model can be represented in diagrams. 
A representation can also have a parent, which is always another representation.



# Use of the specification
The model specification defines:

* The different elements with which a model is constructed.
* The data fields that are associated with each element in the model.
* The use of each model element, both in the hierachical model and in the diagrams.
* How certain events are handled. For instance, if an entity from the hierarchical model is dropped in a diagram,
  the default action is to create a direct representation of that entity. All representations of the entity share
  the same underlying data. But in some cases, another action must
  be taken, like creating an _instance_ of that entity that is independent from other instances, e.g. that has 
  its own set of user-edited parameters.
* Default rendering details for each element. These can be overridden by the editor of the diagram for visual purposes.
* Which elements can be connected to other elements, and how.
* Which elements can be placed in each type of diagram.
* The initial / minimal contents of the database. The explorer does not allow modifying root elements,
  so without initial contents the model can not be filled.
* Invariant rules that safeguard model integrity.

To achieve the various functions, code is generated from the specification:

* A database model is created for persisting data on the server side. This model can also instantiate the database.
* A server is created that handles REST calls from the client. It also implements the Invariant rules and
  implements two queries to serve the hierachy explorer and the diagram editor with all data they need.
* A client HTML page is generated, that gives each tool its own identity.
* A client source code file is generated, the configures the client. This client source code interacts heavily
  with the diagramming library. The diagramming library is not generated by the tool, it has been coded together.



# Design choices
* For now, CompoundEntities only have BlockDiagram inner diagrams, not laned diagrams.

