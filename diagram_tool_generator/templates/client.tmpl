<%
"""
    Template for generating the client for the visual modelling environment.
    The tool expects only a definition construct.
    This

    The generated client uses the Brython Python-In-A-Browser technology.
"""

from dataclasses import fields

%><!doctype html>
<html>

<head>
<meta charset="utf-8">
<script type="text/javascript" src="/src/brython.js"></script>
<script type="text/javascript" src="/src/brython_stdlib.js"></script>
<link rel="stylesheet" type="text/css" href="/assets/css/fontawesome.min.css" />
<link rel="stylesheet" type="text/css" href="/assets/css/solid.min.css" />
<link rel="stylesheet" type="text/css" href="/stylesheet.css" />


</head>


<body onload="brython(1)">
    <div id="explorer"></div>
    <div id="canvas"></div>
    <div id="details"></div>

    <script type="text/python">
        """
        Visual Modelling client.
        """

        from browser import document, console, html, window, bind, ajax
        import json
        from explorer import Element, make_explorer, ExplorerDataApi, context_menu_name
        from dataclasses import dataclass, field, is_dataclass, asdict
        from typing import Self, List, Dict, Any
        from collections.abc import Iterable
        import typing
        import types
        from enum import IntEnum
        import diagrams

        class longstr(str): pass

        # Modelling 'Entities:'
        % for entity in generator.ordered_items:
        @dataclass
        class ${entity.__name__}:
            Id: diagrams.HIDDEN = 0
            % for f in fields(entity):
            ## All elements must have a default value so they can be created from scratch
            ${f.name}: ${generator.get_html_type(f.type)} = ${generator.get_default(f.type)}
            % endfor
            % if not entity in generator.md.relationship:
            order: diagrams.HIDDEN = 0
            children: diagrams.HIDDEN = field(default_factory=list)

            def get_icon(self):
                return "${generator.styling.get(entity.__name__, {}).get('icon') or 'folder'}"
            % endif

        % endfor

        allowed_children = {
            % for name in generator.all_names.keys():
            ${name}: [${', '.join(generator.children[name])}],
            % endfor
        }


        def flatten(data):
            if isinstance(data, Iterable):
                for d in data:
                    yield from flatten(d)
            else:
                yield data
                if hasattr(data, 'children'):
                    yield from flatten(data.children)

        class ExtendibleJsonEncoder(json.JSONEncoder):
            def default(self, o):
                """ We have three tricks to jsonify objects that are not normally supported by JSON.
                    * Dataclass instances are serialised as dicts.
                    * For objects that define a __json__ method, that method is called for serialisation.
                    * For other objects, the str() protocol is used, i.e. the __str__ method is called.
                """
                if hasattr(o, '__json__'):
                    return o.__json__()
                if is_dataclass(o):
                    result = asdict(o)
                    result['__classname__'] = type(o).__name__
                    return result
                return str(o)

        class API(ExplorerDataApi):
            def get_allowed_children(self, id: int):
                element = self.records[id]
                cls = type(element)
                return allowed_children[cls]
            def get_elements_async(self, cb):
                def on_data(data):
                    records = []
                    for d in data.json:
                        cls = globals()[d['__classname__']]
                        ddict = {k:v for k, v in d.items() if k != '__classname__'}
                        records.append(cls(**ddict))
                    self.records = {r.Id: r for r in records}
                    # Determine the actual hierarchy.
                    for r in self.records.values():
                        r.children = []
                    roots = []
                    for r in self.records.values():
                        if r.parent:
                            self.records[r.parent].children.append(r)
                        else:
                            roots.append(r)
                    self.hierarchy = roots
                    cb(self.hierarchy)
                ajax.get('/data/hierarchy', mode="json", oncomplete=on_data)
            def get_element(self, id: int) -> Element:
                raise NotImplementedError
            def add_element(self, details: Element):
                """ Persist a new element created with the right-click menu """
                data = json.dumps(details, cls=ExtendibleJsonEncoder)
                def on_complete(update):
                    details.Id = update.json['Id']
                    self.records[details.Id] = details
                    parent = self.records[details.parent]
                    parent.children.append(details)
                ajax.post(f'/data/{type(details).__name__}', blocking=True, data=data, oncomplete=on_complete,
                          mode='json', headers={"Content-Type": "application/json"})
            def move_element(self, id: int):
                """ Called when an element is moved in the hierarchy. """
                raise NotImplementedError
            def delete_element(self, id: int, clsname: str) -> bool:
                """ Called when an element is deleted.
                    Returns True if the delete was successful, false if not.
                """
                result = False
                def oncomplete(response):
                    nonlocal result
                    if response.status >= 200 and response.status < 300:
                        console.log("Got a good response from the server")
                        result = True
                ajax.delete(f'/data/{clsname}/{id}', blocking=True, oncomplete=oncomplete)
                return result
            def on_click(self, id: int):
                """ Called when an element was left-clicked. """
                console.log(f"Clicked on element {id}")
            def update_element(self, id: int, clsname: str, update: Dict[str, Any]):
                jstr = json.dumps(update)
                ajax.post(f'/data/{clsname}/{id}', blocking=True, data=jstr,
                      mode='json', headers={"Content-Type": "application/json"})

        blank = document["explorer"];
        blank <= html.DIALOG(id=context_menu_name)
        make_explorer(blank, API())

        @bind(blank, 'click')
        @bind(document[context_menu_name], 'click')
        def close_contextmenu(ev):
            ev.stopPropagation()
            ev.preventDefault()
            document[context_menu_name].close()
    </script>
</body>

</html>