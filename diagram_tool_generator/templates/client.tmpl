<%
"""
    Template for generating the client for the visual modelling environment.
    The tool expects only a definition construct.
    This

    The generated client uses the Brython Python-In-A-Browser technology.
"""

from dataclasses import fields, is_dataclass
import model_definition as mdef

%><!doctype html>
<html>

<head>
<meta charset="utf-8">
<script type="text/javascript" src="/src/brython.js"></script>
<script type="text/javascript" src="/src/brython_stdlib.js"></script>
<link rel="stylesheet" type="text/css" href="/assets/css/fontawesome.min.css" />
<link rel="stylesheet" type="text/css" href="/assets/css/solid.min.css" />
<link rel="stylesheet" type="text/css" href="/stylesheet.css" />


</head>


<body onload="brython(1)">
    <div id="explorer"></div>
    <div id="canvas"></div>
    <div id="details"></div>

    <script type="text/python">
        """
        Visual Modelling client.
        """

        from browser import document, console, html, window, bind, ajax
        import json
        from explorer import Element, make_explorer, ExplorerDataApi, context_menu_name
        from dataclasses import dataclass, field, is_dataclass, asdict
        from typing import Self, List, Dict, Any
        from collections.abc import Iterable
        import typing
        import types
        from enum import IntEnum
        import diagrams

        class longstr(str): pass

        # Modelling 'Entities:'
        % for entity in generator.ordered_items:
        @dataclass
        class ${entity.__name__}:
            Id: diagrams.HIDDEN = 0
            % for f in fields(entity):
            ## All elements must have a default value so they can be created from scratch
            ${f.name}: ${generator.get_html_type(f.type)} = ${generator.get_default(f.type)}
            % endfor
            % if not entity in generator.md.relationship:
            order: diagrams.HIDDEN = 0
            children: diagrams.HIDDEN = field(default_factory=list)

            def get_icon(self):
                return "${generator.styling.get(entity.__name__, {}).get('icon') or 'folder'}"
            % endif

        % endfor


        ## Create the representations of the various blocks and relationships
        # Representations of the various graphical elements
        % for cls in generator.md.entity:
        @dataclass
        class ${cls.__name__}Representation(diagrams.${mdef.get_style(cls, 'structure', 'Block')}):
            % for attr in generator.get_diagram_attributes(cls):
            ${attr.name}: ${generator.get_html_type(attr.type)} = ${generator.get_default(attr.type)}
            % endfor

        % endfor
        <%
            def get_relationship_type(field_type):
                if is_dataclass(field_type):
                    return field_type.__name__ + 'Representation'
                if isinstance(field_type, mdef.XRef):
                    types = [t for t in field_type.types if not (isinstance(t, type) and issubclass(t, mdef.OptionalAnnotation))]
                    type_names = ', '.join(get_relationship_type(t) for t in types)
                    return f"[{type_names}]"
                return generator.get_html_type(field_type)
        %>
        % for cls in generator.md.relationship:
        @dataclass
        class ${cls.__name__}Representation(diagrams.Relationship):
            % for attr in fields(cls):
            ${attr.name}: ${get_relationship_type(attr.type)} = ${generator.get_default(attr.type)}
            % endfor

        % endfor

        ## Create the diagram definitions
        # Definitions for rendering the various diagrams
        % for cls in generator.md.diagrams:
        <% block_names = [f'{e.__name__}Representation' for e in cls.__annotations__['entities']] %>
        class ${cls.__name__}Representation(diagrams.Diagram):
            allowed_blocks = [${", ".join(block_names)}]

        % endfor

        allowed_children = {
            % for name in generator.all_names.keys():
            ${name}: [${', '.join(generator.children[name])}],
            % endfor
        }

        diagram_definitions = {
            % for cls in generator.md.diagrams:
            "${cls.__name__}": ${cls.__name__}Representation,
            % endfor
        }



        def flatten(data):
            if isinstance(data, Iterable):
                for d in data:
                    yield from flatten(d)
            else:
                yield data
                if hasattr(data, 'children'):
                    yield from flatten(data.children)

        class EAPI(RestApi, ExplorerDataApi):
            def get_many_url(self):
                return '/data/hierarchy'
            def get_allowed_children(self, id: int):
                element = self.records[id]
                cls = type(element)
                return allowed_children[cls]
            def get_elements_async(self, cb):
                def on_data(records):
                    # Determine the actual hierarchy.
                    for r in records.values():
                        r.children = []
                    roots = []
                    for r in records.values():
                        if r.parent:
                            records[r.parent].children.append(r)
                        else:
                            roots.append(r)
                    self.hierarchy = roots
                    cb(self.hierarchy)
                RestApi.get_elements_async(self, on_data)
            def add_element(self, details: Element):
                """ Persist a new element created with the right-click menu """
                RestApi.add_element(self, details)
                parent = self.records[details.parent]
                parent.children.append(details)
            @self.bind('click')
            def on_click(self, id: int, clsname: str):
                """ Called when an element was left-clicked. """
                console.log(f"Clicked on element {id}")
            @self.bind('dblclick')
            def on_dblclick(self, id: int, clsname: str):
                """ Called when an element was left-clicked. """
                console.log(f"Double-Clicked on element {id}")
                # If a diagram is double-clicked, open it.
                def oncomplete(response):
                    load_diagram(id, diagram_definitions[clsname], self, document['canvas'])
                if clsname in [${', '.join(f'"{c.__name__}"' for c in generator.md.diagrams)}]:
                    ajax.get(f'/data/diagram_contents/{id}', oncomplete=oncomplete)

        class DApi(diagrams.DiagramDataApi):
            def __init__(self, diagram_id):
                self.diagram_id = diagram_id
            def get_elements_async(self, cb):
                """ Retrieve a list of elements.
                    Some of these elements can have children, representing a hierarchy
                """
                def on_data(response):
                    if response.status >=200 and response.status < 300:
                        records = []
                        for d in data.json:
                            cls = globals()[d['__classname__']]
                            ddict = {k:v for k, v in d.items() if k != '__classname__'}
                            records.append(cls(**ddict))
                        cb(records)
                ajax.get(f'/data/diagram_contents/{self.diagram_id}', mode='json', oncomplete=on_data)
            def add_element(self, details: Any):
                """ Persist a new element created with the right-click menu """
                raise NotImplementedError
            def delete_element(self, details: Any) -> bool:
                """ Called when an element is deleted.
                    Returns True if the delete was successful, false if not.
                """
                raise NotImplementedError
            def update_element(self, details: Any):
                raise NotImplementedError
            def trigger_event(self, event_name, details):
                """ Called when an element was left-clicked. """
                raise NotImplementedError

        blank = document["explorer"];
        make_explorer(blank, EAPI())

        @bind(blank, 'click')
        @bind(document[context_menu_name], 'click')
        def close_contextmenu(ev):
            ev.stopPropagation()
            ev.preventDefault()
            document[context_menu_name].close()
    </script>
</body>

</html>