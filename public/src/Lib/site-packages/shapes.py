
try:
    from browser import document, alert, svg, console, window
except:
    document = {}
    alert = None
    class svg:
        pass
    svg_elements = ['line', 'circle', 'path', 'rect']
    functions = {k: (lambda self, **kargs: kargs) for k in svg_elements}
    svg.__dict__.update(functions)


import enum
from weakref import ref
import math
from math import inf
from dataclasses import dataclass, field
import json
from typing import List
from itertools import chain
from square_routing import routeSquare
from point import Point
from fontsizes import font_sizes


def getMousePos(ev):
    CTM = ev.target.getScreenCTM()
    return Point(x=int((ev.clientX - CTM.e)/CTM.a), y=int((ev.clientY-CTM.f)/CTM.d))


class Orientations(enum.IntEnum):
    TL = 1
    TOP = 2
    TR = 3
    RIGHT = 4
    BR = 5
    BOTTOM = 6
    BL = 7
    LEFT = 8

class BlockOrientations(enum.IntEnum):
    TOP = Orientations.TOP
    RIGHT = Orientations.RIGHT
    BOTTOM = Orientations.BOTTOM
    LEFT = Orientations.LEFT


id_counter = 0
def getId():
    global id_counter
    id_counter += 1
    return id_counter


class HIDDEN:
    def __init__(self, t):
        self.type = t


class VAlign(enum.IntEnum):
    TOP = 1
    CENTER = 2
    BOTTOM = 3

class HAlign(enum.IntEnum):
    LEFT = 10
    CENTER = 11
    RIGHT = 12
    JUSTIFIED = 13

POINT_TO_PIXEL = 1.3333

def wrapText(text, width, font='Arial.ttf', fontsize='10'):
    # Separate into words and determine the size of each part
    font = font_sizes['Arial.ttf']['sizes']
    parts = text.split()
    normalized_width = width / POINT_TO_PIXEL / fontsize
    sizes = [sum(font[ord(ch)] for ch in part) for part in parts]

    # Now fill the lines
    line_length = 0
    lines = []
    current_line = []
    for size, part in zip(sizes, parts):
        if line_length + size + font[32]*(len(current_line)-1) > normalized_width:
            lines.append(' '.join(current_line))
            current_line = []
            line_length = 0
        current_line.append(part)
        line_length += size
    if current_line:
        lines.append(' '.join(current_line))
    return lines

def renderText(text, x, y, width, height, style):
    font_file = style.getStyle('font')+'.ttf'
    fontsize = float(style.getStyle('fontsize'))
    lines = wrapText(text, width, font_file, fontsize)
    # Now render these lines
    anchor = {HAlign.LEFT: 'start', HAlign.CENTER: 'middle', HAlign.RIGHT: 'end'}[style.getStyle('halign')]
    lineheight = font_sizes[font_file]['lineheight'] * fontsize
    # Calculate where the text must be placed.
    xpos = int({HAlign.LEFT: x+style.getStyle('xmargin'), HAlign.CENTER: x+width/2, HAlign.RIGHT: x+width-style.getStyle('xmargin')}[style.getStyle('halign')])
    ypos = {#VAlign.TOP: y+ymargin,
            VAlign.CENTER: y+(height-len(lines)*lineheight)/2
            #VAlign.BOTTOM: y+height-len(lines)*lineheight*fontsize - ymargin
           }[style.getStyle('valign')]

    rendered = [svg.text(line, x=xpos, y=int(ypos+lineheight*(i+1)), text_anchor=anchor, font_size=fontsize, font_family=style.getStyle('font', None))
                for i, line in enumerate(lines)]
    return rendered



class BasicShape:
    style_items = {'bordercolor': 'black', 'bordersize': '2', 'blockcolor': 'white'}
    @classmethod
    def getShape(cls, details):
        raise NotImplementedError
    @classmethod
    def updateShape(cls, shape, details):
        raise NotImplementedError
    @staticmethod
    def getDescriptor(name):
        name = name.lower()
        for cls in BasicShape.getShapeTypes():
            if cls.__name__.lower() == name.lower():
                return cls
        raise RuntimeError(f"Unknown shape type {name}")
    @classmethod
    def getShapeTypes(cls):
        return cls.__subclasses__() + list(chain.from_iterable(c.getShapeTypes() for c in cls.__subclasses__()))

    @classmethod
    def getType(cls):
        return cls.__name__.lower()

    @classmethod
    def getStyle(cls, key, details):
        # Find a default value for the style item
        default = cls.style_items.get(key, None)
        if default is None:
            for c in cls.mro():
                if key in c.style_items:
                    default = c.style_items[key]
                    break
        return details.getStyle(key, default)


class Rect(BasicShape):
    style_items = {'cornerradius': '0'}
    @classmethod
    def getShape(cls, details):
        return svg.rect(x=details.x, y=details.y, width=details.width, height=details.height,
                        stroke_width=cls.getStyle('bordersize', details),
                        stroke=cls.getStyle('bordercolor', details),
                        fill=cls.getStyle('blockcolor', details),
                        ry=cls.getStyle('cornerradius', details))
    @classmethod
    def updateShape(cls, shape, details):
        shape['width'], shape['height'] = details.width, details.height
        shape['x'], shape['y'] = details.x, details.y

class Circle(BasicShape):
    style_items = {}
    @classmethod
    def getShape(cls, details):
        return svg.circle(cx=details.x+details.width//2, cy=details.y+details.height//2,
                        r=(details.width+details.height)//4,
                        stroke_width=cls.getStyle('bordersize', details),
                        stroke=cls.getStyle('bordercolor', details),
                        fill=cls.getStyle('blockcolor', details))
    @classmethod
    def updateShape(cls, shape, details):
        shape['r'] = (details.width + details.height) // 4
        shape['cx'], shape['cy'] = details.x+details.width//2, details.y+details.height//2

class Ellipse(BasicShape):
    style_items = {}
    @classmethod
    def getShape(cls, details):
        return svg.ellipse(cx=details.x+details.width//2, cy=details.y+details.height//2,
                        rx=details.width//2, ry=details.height//2,
                        stroke_width=cls.getStyle('bordersize', details),
                        stroke=cls.getStyle('bordercolor', details),
                        fill=cls.getStyle('blockcolor', details))
    @classmethod
    def updateShape(cls, shape, details):
        shape['rx'], shape['ry'] = details.width//2, details.height//2
        shape['cx'], shape['cy'] = details.x+details.width//2, details.y+details.height//2

class Note(BasicShape):
    style_items = {'fold_size': '10'}
    @classmethod
    def getPoints(cls, details):
        x, y, w, h = details.x, details.y, details.width, details.height
        f = int(cls.getStyle('fold_size', details))
        return [(x+a,y+b) for a, b in [(0,0), (w-f,0), (w,f), (w-f,f), (w-f,0), (w,f), (w,h), (0,h), (0,0)]]
    @classmethod
    def getShape(cls, details):
        outline = svg.polyline(points=' '.join(f'{x},{y}' for x, y in cls.getPoints(details)),
                              fill=cls.getStyle('blockcolor', details), stroke=cls.getStyle('bordercolor', details),
                              stroke_width=cls.getStyle('bordersize', details))
        return outline
    @classmethod
    def updateShape(cls, shape, details):
        shape['points'] = ' '.join(f'{x},{y}' for x, y in cls.getPoints(details))


class Component(BasicShape):
    style_items = {'ringwidth': '15', 'ringheight': '10', 'ringpos': '25', 'cornerradius': '0'}
    @classmethod
    def getShape(cls, details):
        g = svg.g()
        # Add the basic rectangle
        g <= Rect.getShape(details)
        # Add the two binder rings
        rw, rh, rp = [int(cls.getStyle(i, details)) for i in 'ringwidth ringheight ringpos'.split()]
        rp = rp * details.height // 100
        g <= svg.rect(x=details.x-rw//2,
                      y=details.y+rp,
                      width=cls.getStyle('ringwidth', details),
                      height=cls.getStyle('ringheight', details),
                      stroke_width=cls.getStyle('bordersize', details),
                      stroke=cls.getStyle('bordercolor', details),
                      fill=cls.getStyle('blockcolor', details))
        g <= svg.rect(x=details.x-rw//2,
                      y=details.y+details.height-rp-rh,
                      width=cls.getStyle('ringwidth', details),
                      height=cls.getStyle('ringheight', details),
                      stroke_width=cls.getStyle('bordersize', details),
                      stroke=cls.getStyle('bordercolor', details),
                      fill=cls.getStyle('blockcolor', details))
        return g
    @classmethod
    def updateShape(cls, shape, details):
        # Update the large square
        Rect.updateShape(shape.children[0], details)
        # Update the rings
        rw, rh, rp = [int(cls.getStyle(i, details)) for i in 'ringwidth ringheight ringpos'.split()]
        rp = rp * details.height // 100
        r1, r2 = shape.children[1:]
        r1['x'] = details.x-rw//2
        r2['x'] = details.x-rw//2
        r1['y'] = details.y+rp
        r2['y'] = details.y+details.height-rp-rh

class Diamond(Note):
    @classmethod
    def getPoints(cls, details):
        return [(details.x+a, details.y+b) for a, b in [
            (details.width//2,0), 
            (details.width,details.height//2),
            (details.width//2,details.height),
            (0,details.height//2),
            (details.width//2,0)]]

class ClosedCircle(Circle):
    @classmethod
    def getShape(cls, details):
        shape = Circle.getShape(details)
        shape['fill'] = cls.getStyle('bordercolor', details)
        return shape

class RingedClosedCircle(BasicShape):
    style_items = {'space': '25'}
    @classmethod
    def getShape(cls, details):
        r = (details.width + details.height) // 4
        space = int(cls.getStyle('space', details)) * r // 100
        ball = ClosedCircle.getShape(details)
        ball['r'] = r - space
        ring = Circle.getShape(details)
        ring['fill'] = 'none'
        g = svg.g()
        g <= ball
        g <= ring
        return g
    @classmethod
    def updateShape(cls, shape, details):
        r = (details.width + details.height) // 4
        space = int(cls.getStyle('space', details)) * r // 100
        ClosedCircle.updateShape(shape.children[0], details)
        Circle.updateShape(shape.children[1], details)
        shape.children[0]['r'] = r - space

class Bar(Rect):
    style_items = {'blockcolor': 'black'}
    @classmethod
    def getShape(cls, details):
        return svg.rect(x=details.x, y=details.y, width=details.width, height=details.height,
                        stroke_width=cls.getStyle('bordersize', details),
                        stroke=cls.getStyle('blockcolor', details),
                        fill=cls.getStyle('blockcolor', details),
                        ry=cls.getStyle('cornerradius', details))

class Hexagon(Note):
    style_items = {'bump': '15'}
    @classmethod
    def getPoints(cls, details):
        bump = int(cls.getStyle('bump', details))
        return [(details.x+a, details.y+b) for a, b in [
            (0, 0),
            (details.width, 0),
            (details.width+bump, details.height//2),
            (details.width, details.height),
            (0, details.height),
            (-bump, details.height//2),
            (0,0)]]

class Octagon(Hexagon):
    @classmethod
    def getPoints(cls, details):
        bump = int(cls.getStyle('bump', details))
        return [(details.x+a, details.y+b) for a, b in [
            (0, 0),
            (details.width, 0),
            (details.width+bump, details.height//4),
            (details.width+bump, 3*details.height//4),
            (details.width, details.height),
            (0, details.height),
            (-bump, 3*details.height//4),
            (-bump, details.height//4),
            (0,0)]]

class Box(Note):
    style_items = {'offset': '10'}
    @classmethod
    def getPoints(cls, details):
        offset = int(cls.getStyle('offset', details))
        return [(details.x + a, details.y + b) for a, b in [
            (0, 0),
            (details.width, 0),
            (details.width, details.height),
            (0, details.height),
            (0, 0),
            (offset, -offset),
            (details.width+offset, -offset),
            (details.width, 0),
            (details.width + offset, -offset),
            (details.width + offset, -offset+details.height),
            (details.width, details.height)
        ]]

class Drum(BasicShape):
    style_items = {'curve_height': '15'}
    @classmethod
    def getPath(cls, details):
        h, w = details.height, details.width
        x1, y1 = details.x, details.y
        x2, y2 = x1+w, y1+h
        ch = int(cls.getStyle('curve_height', details)) * w // 100
        return ' '.join([f'M {x1} {y1}',
                         f'v {h}',
                         f'C {x1} {y2+ch} {x2} {y2+ch} {x2} {y2}',
                         f'v -{h}',
                         f'C {x2} {y1+ch} {x1} {y1+ch} {x1} {y1}',
                         f'C {x1} {y1-ch} {x2} {y1-ch} {x2} {y1}'])

    @classmethod
    def getShape(cls, details):
        return svg.path(d=cls.getPath(details),
                        stroke_width=cls.getStyle('bordersize', details),
                        stroke=cls.getStyle('bordercolor', details),
                        fill=cls.getStyle('blockcolor', details))

    @classmethod
    def updateShape(cls, shape, details):
        shape['d'] = cls.getPath(details)

class Stickman(Drum):
    style_items = {'proportions': '25 33 66'}
    @classmethod
    def getPath(cls, details):
        proportions = [int(i) for i in cls.getStyle('proportions', details).split()]
        x1 = details.x
        x2 = details.x + details.width//2
        x3 = details.x + details.width
        y1 = details.y
        r = details.height * proportions[0] // 200
        y2 = y1 + proportions[0] * details.height // 100
        y3 = y1 + proportions[1] * details.height // 100
        y4 = y1 + proportions[2] * details.height // 100
        y5 = y1 + details.height
        return f'M {x2-1} {y2} a {r} {r} 0 1 1 1 0 L {x2} {y4} M {x1} {y3} L {x3} {y3} M {x1} {y5} L {x2} {y4} L {x3} {y5}'


def Text(text_attr):
    """ Depending on the shape, the text is obtained from any attribute in the details.
        So we make the text widget available though a function that bind it to an attribute.
    """
    class TextWidget(BasicShape):
        style_items = dict(font='Arial', fontsize='16', textcolor='black', xmargin=2, ymargin=2, halign=HAlign.CENTER, valign=VAlign.CENTER)
        @classmethod
        def getShape(cls, details):
            # The text lines are wrapped in a group.
            g = svg.g()
            g <= renderText(getattr(details, text_attr), x=details.x, y=details.y, width=details.width, height=details.height, style=details)
            return g
        @classmethod
        def updateShape(cls, shape, details):
            # Simply delete the previous text and write anew.
            for line in shape.children:
                line.remove()
            shape <= renderText(getattr(details, text_attr), x=details.x, y=details.y, width=details.width, height=details.height, style=details)
    return TextWidget

# TODO:
# class Package: -- needs to contain other blocks.
# class Group:
# class Cloud:


class OwnerInterface:
    """ Define an interface through which a shape interacts with its parent.
        A parent can either be another shape, or the SVG canvas itself.

        Python doesn't need interfaces, this is added for documentation purposes.
    """
    def clickChild(self, widget, ev):
        raise NotImplementedError
    def mouseDownChild(self, widget, ev):
        raise NotImplementedError
    def mouseDownConnection(self, connection, ev):
        raise NotImplementedError
    def getCanvas(self):
        raise NotImplementedError
    def __le__(self, svg_widget):
        raise NotImplementedError
    def evaluateOwnership(self, widget, pos, ex_owner):
        # Check this widget is dropped on me
        if hasattr(self, 'owner'):
            if pos.x < self.x or pos.x > self.x+self.width or pos.y < self.y or pos.y > self.y+self.height:
                owner = self.owner()
                return owner.evaluateOwnership(widget, pos, ex_owner)
        # Check if this widget is actually dropped on a child container.
        containers = [c for c in self.children if isinstance(c, OwnerInterface)]
        for c in containers:
            # A container can not contain itself
            if c == widget:
                continue
            if pos.x < c.x or pos.x > c.x+c.width or pos.y < c.y or pos.y > c.y+c.height:
                continue
            # The release point is inside this container. Make it the owner.
            return c.evaluateOwnership(widget, pos, self)

        # We are to take ownership of this shape.
        if owner := widget.owner():
            # If we already were the owner, do nothing.
            if owner == self:
                return
            owner.children.remove(widget)
        self.children.append(widget)
        widget.owner = ref(self)
        console.log("Switched ownership")


@dataclass
class Shape:
    x: float
    y: float
    height: float
    width: float
    name: str
    shape_type: str = 'rect'
    styling: dict = field(default_factory=dict)
    id: HIDDEN(int) = field(default_factory=getId)

    shape_descriptor = None
    default_style = dict()
    owner = None

    def isResizable(self):
        return True

    def getPos(self):
        return Point(x=self.x, y=self.y)
    def setPos(self, new):
        self.x, self.y = new.astuple()
        self.updateShape(self.shape)
        for s in self.subscribers.values():
            s(self)
    def getSize(self):
        return Point(x=self.width, y=self.height)
    def setSize(self, new):
        self.width, self.height = new.astuple()
        self.updateShape(self.shape)

    def getStyle(self, key, default=None):
        if key in self.styling:
            return self.styling[key]
        if key in self.default_style:
            return self.default_style[key]
        if default is not None:
            return default
        raise RuntimeError(f"Trying to retrieve unknown styling element {key}")

    def getShape(self):
        return self.shape_descriptor.getShape(self)

    def updateShape(self, shape):
        if (not self.shape_descriptor) or self.shape_type.lower() != self.shape_descriptor.getType():
            self.shape.remove()
            self.shape_descriptor = BasicShape.getDescriptor(self.shape_type)
            self.shape = self.getShape()
        else:
            self.shape_descriptor.updateShape(shape, self)

    def delete(self):
        self.shape.remove()

    def subscribe(self, role, f):
        self.subscribers[role] = f

    def unsubscribe(self, role):
        if role in self.subscribers:
            del self.subscribers[role]

    def onHover(self, ev):
        pass

    def onClick(self, ev):
        if owner := self.owner():
            owner.clickChild(self, ev)

    def onMouseDown(self, ev):
        if owner := self.owner():
            owner.mouseDownChild(self, ev)

    #################################
    ## Low level handlers
    ## These handlers are used to determine high-level events.
    def onMouseEnter(self, ev):
        # This becomes a "hover" event when no mouse button is clicked.
        if ev.buttons == 0:
            self.onHover(ev)

    def create(self, owner):
        self.owner = ref(owner)

        canvas = owner.canvas
        self.subscribers = {}

        self.shape_descriptor = BasicShape.getDescriptor(self.shape_type)
        self.shape = self.getShape()
        canvas <=  self.shape

        self.shape.bind('click', self.onClick)
        self.shape.bind('mousedown', self.onMouseDown)

    def destroy(self):
        pass

    def getCenter(self):
        return self.getPos() + self.getSize()/2

    def getIntersection(self, b):
        halfsize = self.getSize()/2
        a = self.getCenter()
        delta = b - a
        if abs(delta.x) > 1:
            rc = delta.y / delta.x
            i_left = Point(math.copysign(halfsize.x, delta.x), math.copysign(rc*halfsize.x, delta.y))
            if abs(i_left.y) < halfsize.y:
                return i_left + a
        rc = delta.x / delta.y
        i_top = Point(math.copysign(rc*halfsize.y, delta.x), math.copysign(halfsize.y, delta.y))
        return i_top + a

    def getConnectionTarget(self, ev):
        """ Determine if the user clicked on a child like a port """
        # A basic shape has only one connection
        return self

    def isConnected(self, target):
        return target == self

    def update(self, values_json):
        values = json.loads(values_json)
        for key, value in values.items():
            setattr(self, key, value)
        self.updateShape(self.shape)







@dataclass
class CP:
    orientation: BlockOrientations
    order: int
    id: HIDDEN(int) = field(default_factory=getId)

    def onHover(self):
        pass

    def onConnect(self):
        pass

    def onDrag(self):
        pass

class RoutingMethod(enum.IntEnum):
    CenterTCenter = 1
    Squared = 2

class RoutingStragegy:
    def decorate(self, connection, canvas):
        raise NotImplementedError
    def route(self, shape, all_blocks):
        raise NotImplementedError
    def dragEnd(self, canvas):
        pass

class RouteCenterToCenter(RoutingStragegy):
    def __init__(self):
        self.decorators = []
        self.widget = None
        self.drag_start = None

    def createWaypointByDrag(self, pos, connection, canvas):
        self.dragged_index = self.widget.insertWaypoint(pos)
        self.initial_pos = self.drag_start = self.widget.waypoints[self.dragged_index]
        self.clear_decorations()
        self.decorate(connection, canvas)

    def dragHandle(self, pos):
        delta = pos - self.drag_start
        new_pos = self.initial_pos + delta
        handle = self.decorators[self.dragged_index]
        handle['cx'], handle['cy'] = new_pos.x, new_pos.y
        self.widget.waypoints[self.dragged_index] = new_pos

    def mouseDownHandle(self, decorator_id, ev):
        self.dragged_index = decorator_id
        self.drag_start = getMousePos(ev)
        self.initial_pos = self.widget.waypoints[decorator_id]
        current = ev.target
        current.dispatchEvent(window.CustomEvent.new("handle_drag_start", {"bubbles":True, "detail": {'router': self}}))
        ev.stopPropagation()
        ev.preventDefault()

    def deleteWaypoint(self):
        if self.dragged_index is not None and self.dragged_index < len(self.widget.waypoints):
            self.widget.waypoints.pop(self.dragged_index)
            self.clear_decorations()
            self.decorate(self.widget, self.widget.canvas)

    def decorate(self, connection, canvas):
        self.widget = connection
        self.decorators = [svg.circle(cx=p.x, cy=p.y, r=5, stroke_width=0, fill="#29B6F2") for p in self.widget.waypoints]
        def bind(i, d):
            d.bind('mousedown', lambda ev: self.mouseDownHandle(i, ev))
        for i, d in enumerate(self.decorators):
            canvas <= d
            # Python shares variables inside a for loop by reference
            # So to avoid binding to the same handle x times, we need to call a function to make permanent copies.
            bind(i, d)

    def clear_decorations(self):
        for d in self.decorators:
            d.remove()
        self.decorators = []

    def route(self, shape, all_blocks):
        # Determine the centers of both blocks
        c_a = shape.start.getCenter()
        c_b = shape.finish.getCenter()

        # Get the points where the line intersects both blocks
        i_a = shape.start.getIntersection(c_b if not shape.waypoints else shape.waypoints[0])
        i_b = shape.finish.getIntersection(c_a if not shape.waypoints else shape.waypoints[-1])

        # Move the line
        waypoints = ''.join(f'L {p.x} {p.y} ' for p in shape.waypoints)
        shape.path['d'] = f"M {i_a.x} {i_a.y} {waypoints}L {i_b.x} {i_b.y}"
        shape.selector['d'] = f"M {i_a.x} {i_a.y} {waypoints}L {i_b.x} {i_b.y}"

        # Store the actual intersection points
        shape.terminations = (i_a, i_b)


class RouteSquare(RoutingStragegy):
    def __init__(self):
        self.decorators = []
        self.dragged_index = None
    def mouseDownHandle(self, decorator_id, ev):
        self.dragged_index = decorator_id
        self.drag_start = getMousePos(ev)
        current = ev.target
        current.dispatchEvent(window.CustomEvent.new("handle_drag_start", {"bubbles":True, "detail": {'router': self}}))
        ev.stopPropagation()
        ev.preventDefault()
    def createWaypointByDrag(self, ev, connection, canvas):
        # WIth this router, new line segments are created differenly.
        pass
    def dragHandle(self, ev):
        wp_index = self.handle_wp_index[self.dragged_index]
        # Create a new waypoint if necessary
        if (new := math.ceil(wp_index)) != wp_index:
            # We need to create a new waypoint
            if self.handle_orientation[self.dragged_index] == 'X':
                waypoint = Point(x=self.widget.points[self.dragged_index].x, y=inf)
            else:
                waypoint = Point(x=inf, y=self.widget.points[self.dragged_index].y)
            self.widget.waypoints.insert(new, waypoint)
            self.handle_wp_index = self.getHandleWpIndices(self.widget.waypoints, self.widget.points)
            wp_index = new
        # Now we can start moving the waypoint.
        delta = getMousePos(ev) - self.drag_start
        new_pos = self.initial_pos[self.dragged_index] + delta
        h = self.decorators[self.dragged_index]
        if self.widget.waypoints[wp_index].x == inf:
            self.widget.waypoints[wp_index].y = new_pos.y
            h['y1'] = int(self.original_handle_pos[self.dragged_index][0].y + delta.y)
            h['y2'] = int(self.original_handle_pos[self.dragged_index][0].y + delta.y)
        else:
            self.widget.waypoints[wp_index].x = new_pos.x
            h['x1'] = int(self.original_handle_pos[self.dragged_index][0].x + delta.x)
            h['x2'] = int(self.original_handle_pos[self.dragged_index][0].x + delta.x)

    def dragEnd(self, canvas):
        self.clear_decorations()
        self.decorate(self.widget, canvas)

    def deleteWaypoint(self):
        wp_index = self.handle_wp_index[self.dragged_index]
        if (new := math.ceil(wp_index)) != wp_index:
            # There is no waypoint associated with this handle
            return
        self.widget.waypoints.pop(wp_index)
        self.clear_decorations()

    @staticmethod
    def getHandleWpIndices(waypoints, points):
        if not waypoints:
            return [-0.5 for _ in points[:-1]]

        current_wp_index = 0
        indices = []
        for p in points[:-1]:
            if current_wp_index >= len(waypoints):
                indices.append(len(waypoints)-0.5)
                continue
            wp = waypoints[current_wp_index]
            if wp.x == inf:
                if wp.y == p.y:
                    indices.append(current_wp_index)
                    current_wp_index += 1
                else:
                    indices.append(current_wp_index-0.5)
            else:
                if wp.x == p.x:
                    indices.append(current_wp_index)
                    current_wp_index += 1
                else:
                    indices.append(current_wp_index-0.5)
        return indices

    def decorate(self, connection, canvas):
        def bind(i, d):
            d.bind('mousedown', lambda ev: self.mouseDownHandle(i, ev))
        # Show a little stripe next to each line-piece
        self.decorators = []
        self.initial_pos = {}
        self.widget = connection
        self.handle_orientation = []
        self.handle_wp_index = self.getHandleWpIndices(self.widget.waypoints, self.widget.points)
        self.original_handle_pos = []
        for p1, p2 in zip(self.widget.points[:-1], self.widget.points[1:]):
            v = (p2 - p1)
            vn = v / len(v)
            c = (p1 + p2) / 2
            n = vn.transpose()
            self.handle_orientation.append('X' if abs(n.x) > abs(n.y) else 'Y')
            p1 = c + 10 * n - 20 * vn
            p2 = c + 10 * n + 20 * vn
            self.original_handle_pos.append((p1, p2))
            decorator = svg.line(x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y, stroke_width=6, stroke="#29B6F2")
            bind(len(self.decorators), decorator)
            self.initial_pos[len(self.decorators)] = c
            canvas <= decorator
            self.decorators.append(decorator)

    def clear_decorations(self):
        for d in self.decorators:
            d.remove()
        self.decorators = []

    def route(self, shape, all_blocks):
        # The actual algorithm for routing squared paths is quite complicated.
        # Therefore it is delegated to a separate function.
        shape.points = routeSquare((shape.start.getPos(), shape.start.getSize()),
                                   (shape.finish.getPos(), shape.finish.getSize()),
                                   shape.waypoints)

        waypoints = ''.join(f'L {p.x} {p.y} ' for p in shape.points[1:])
        start, end = shape.points[0], shape.points[-1]
        shape.path['d'] = f"M {start.x} {start.y} {waypoints}"
        shape.selector['d'] = f"M {start.x} {start.y} {waypoints}"
        shape.terminations = (start, end)


router_classes = {RoutingMethod.CenterTCenter: RouteCenterToCenter, RoutingMethod.Squared: RouteSquare}

@dataclass
class Relationship:
    start: Point
    finish: Point
    waypoints: List[Point]
    routing_method: RoutingMethod
    id: HIDDEN(int) = field(default_factory=getId)
    styling: dict = field(default_factory=dict)
    default_style = dict(linecolor='black', linewidth='2', endmarker='arrow', startmarker='arrow')

    @property
    def canvas(self):
        return self.owner.canvas

    def onHover(self):
        pass

    def onDrag(self):
        pass

    def getMenu(self):
        pass

    def onMouseDown(self, ev):
        self.owner.mouseDownConnection(self, ev)

    def insertWaypoint(self, pos):
        # Find the spot to insert the waypoint.
        # We insert it where the distance to the line between the two adjacent points is smallest
        allpoints = [self.terminations[0]] + self.waypoints + [self.terminations[1]]
        adjacents = zip(allpoints[:-1], allpoints[1:])
        distances = []
        for a, b in adjacents:
            v = b - a
            vmin = a - b
            n = Point(x=v.y, y=-v.x)
            d1 = pos - a
            d2 = pos - b
            # Check if the point is "behind" the segment
            # These we give infinite distance
            if v.dot(d1) < 0 or vmin.dot(d2) < 0:
                distances.append(math.inf)
            else:
                distances.append(abs(n.dot(d1)))
        # Find the smallest distance
        minimum = min(distances)
        index = distances.index(minimum)
        self.waypoints.insert(index, pos)
        return index

    def reroute(self, all_blocks):
        router = getattr(self, 'router', None) or router_classes[self.routing_method]()
        router.route(self, all_blocks)
        self.router = router

    def route(self, owner, all_blocks):
        """ The default routing is center-to-center. """
        self.owner = owner
        # Create the line
        self.path = svg.path(d="", stroke=self.getStyle('linecolor'), stroke_width=self.getStyle('linewidth'),
                             marker_end=f"url(#end{self.getStyle('endmarker')})",
                             marker_start=f"url(#start{self.getStyle('startmarker')})", fill="none")
        # Above the visible path, there is an invisible one used to give a wider selection region.
        self.selector = svg.path(d="", stroke="gray", stroke_width="10", fill="none", opacity="0.0")
        self.reroute(all_blocks)
        self.path.bind('mousedown', self.onMouseDown)
        self.selector.bind('mousedown', self.onMouseDown)
        self.owner.canvas <= self.selector
        self.owner.canvas <= self.path

    def delete(self):
        self.selector.remove()
        self.path.remove()

    def getStyle(self, key, default=None):
        if key in self.styling:
            return self.styling[key]
        if key in self.default_style:
            return self.default_style[key]
        if default is not None:
            return default
        raise RuntimeError(f"Trying to retrieve unknown styling element {key}")


@dataclass
class Container(Shape, OwnerInterface):
    """
    A container is very similar to a regular shape, with a few exceptions.
    The biggest is that when a container is moved, its children move as well.
    A second one is that waypoints for internal connections are constrained to the container.
    """
    children: Shape = field(default_factory=list)

    shape_descriptor = Rect

    def clickChild(self, widget, ev):
        if owner := self.owner():
            owner.clickChild(widget, ev)
    def mouseDownChild(self, widget, ev):
        if owner := self.owner():
            owner.mouseDownChild(widget, ev)

    def mouseDownConnection(self, connection, ev):
        if owner := self.owner():
            owner.mouseDownConnection(connection, ev)

    def getCanvas(self):
        if owner := self.owner():
            return owner.getCanvas()

    def __le__(self, svg_widget):
        if owner := self.owner():
            return owner <= svg_widget

    # Function to manipulate the schematic
    def setPos(self, new):
        # Determine the delta
        delta = Point(new.x - self.x, new.y - self.y)
        # Set the new position of this shape
        super().setPos(new)

        # Also update the positions for all the children
        for child in self.children:
            child.setPos(child.getPos() + delta)

        # And re-route any relationships to the children
        if owner := self.owner():
            for child in self.children:
                owner.rerouteConnections(child)

    def setSize(self, new):
        # Keep the rect large enough to fit all children.
        if self.children:
            min_width = max([c.x+c.width-self.x for c in self.children]) + 5
            min_height = max([c.y+c.height-self.y for c in self.children]) + 5
            if new.x < min_width:
                new.x = min_width
            if new.y < min_height:
                new.y = min_height
        super().setSize(new)

    def rerouteConnections(self, shape):
        # For now, all connections are stored at the diagram level.
        if owner := self.owner():
            owner.rerouteConnections(shape)

