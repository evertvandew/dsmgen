
try:
    from browser import document, alert, svg, console, window
except:
    document = {}
    alert = None
    class svg:
        pass
    svg_elements = ['line', 'circle', 'path', 'rect']
    functions = {k: (lambda self, **kargs: kargs) for k in svg_elements}
    svg.__dict__.update(functions)


from square_routing import routeSquare
from point import Point
import enum
from weakref import ref
import math
from math import inf
from dataclasses import dataclass, field
import json
from typing import List


def getMousePos(ev):
    CTM = ev.target.getScreenCTM()
    return Point(x=int((ev.clientX - CTM.e)/CTM.a), y=int((ev.clientY-CTM.f)/CTM.d))


class Orientations(enum.IntEnum):
    TL = 1
    TOP = 2
    TR = 3
    RIGHT = 4
    BR = 5
    BOTTOM = 6
    BL = 7
    LEFT = 8

class BlockOrientations(enum.IntEnum):
    TOP = Orientations.TOP
    RIGHT = Orientations.RIGHT
    BOTTOM = Orientations.BOTTOM
    LEFT = Orientations.LEFT


id_counter = 0
def getId():
    global id_counter
    id_counter += 1
    return id_counter


class HIDDEN:
    def __init__(self, t):
        self.type = t


def Styled(items):
    all_items = items.split()
    class Styling:
        pass
    return Styling

@dataclass
class Shape(Styled('font fontsize blockcolor textcolor bordercolor bordersize cornerradius')):
    x: float
    y: float
    height: float
    width: float
    name: str
    id: HIDDEN(int) = field(default_factory=getId)

    def isResizable(self):
        return True

    def getPos(self):
        return Point(x=self.x, y=self.y)
    def setPos(self, new):
        self.x, self.y = new.astuple()
        self.updateShape(self.shape)
        for s in self.subscribers.values():
            s(self)
    def getSize(self):
        return Point(x=self.width, y=self.height)
    def setSize(self, new):
        self.width, self.height = new.astuple()
        self.updateShape(self.shape)
    def updateShape(self, shape):
        shape['width'], shape['height'] = self.width, self.height
        shape['x'], shape['y'] = self.x, self.y
    def delete(self):
        self.shape.remove()

    def subscribe(self, role, f):
        self.subscribers[role] = f

    def unsubscribe(self, role):
        if role in self.subscribers:
            del self.subscribers[role]

    def onHover(self, ev):
        pass

    def onClick(self, ev):
        if diagram := self.diagram():
            diagram.clickChild(self, ev)

    def onMouseDown(self, ev):
        if diagram := self.diagram():
            diagram.mouseDownChild(self, ev)

    #################################
    ## Low level handlers
    ## These handlers are used to determine high-level events.
    def onMouseEnter(self, ev):
        # This becomes a "hover" event when no mouse button is clicked.
        if ev.buttons == 0:
            self.onHover(ev)

    def getShape(self):
        return svg.rect(x=self.x,y=self.y, width=self.width, height=self.height, stroke_width="2",stroke="black",fill="white")
    def create(self, diagram):
        self.diagram = ref(diagram)

        canvas = diagram.canvas
        self.subscribers = {}
        self.shape = self.getShape()
        canvas <=  self.shape

        self.shape.bind('click', self.onClick)
        self.shape.bind('mousedown', self.onMouseDown)

    def destroy(self):
        pass

    def getCenter(self):
        return self.getPos() + self.getSize()/2

    def getIntersection(self, b):
        halfsize = self.getSize()/2
        a = self.getCenter()
        delta = b - a
        if abs(delta.x) > 1:
            rc = delta.y / delta.x
            i_left = Point(math.copysign(halfsize.x, delta.x), math.copysign(rc*halfsize.x, delta.y))
            if abs(i_left.y) < halfsize.y:
                return i_left + a
        rc = delta.x / delta.y
        i_top = Point(math.copysign(rc*halfsize.y, delta.x), math.copysign(halfsize.y, delta.y))
        return i_top + a

    def getConnectionTarget(self, ev):
        """ Determine if the user clicked on a child like a port """
        # A basic shape has only one connection
        return self

    def isConnected(self, target):
        return target == self

    def update(self, values_json):
        values = json.loads(values_json)
        for key, value in values.items():
            setattr(self, key, value)
        self.updateShape(self.shape)

@dataclass
class CP:
    orientation: BlockOrientations
    order: int
    id: HIDDEN(int) = field(default_factory=getId)

    def onHover(self):
        pass

    def onConnect(self):
        pass

    def onDrag(self):
        pass

class RoutingMethod(enum.IntEnum):
    CenterTCenter = 1
    Squared = 2

class RoutingStragegy:
    def decorate(self, connection, canvas):
        raise NotImplementedError
    def route(self, shape, all_blocks):
        raise NotImplementedError
    def dragEnd(self, canvas):
        pass

class RouteCenterToCenter(RoutingStragegy):
    def __init__(self):
        self.decorators = []
        self.widget = None
        self.drag_start = None

    def createWaypointByDrag(self, pos, connection, canvas):
        self.dragged_index = self.widget.insertWaypoint(pos)
        self.initial_pos = self.drag_start = self.widget.waypoints[self.dragged_index]
        self.clear_decorations()
        self.decorate(connection, canvas)

    def dragHandle(self, pos):
        delta = pos - self.drag_start
        new_pos = self.initial_pos + delta
        handle = self.decorators[self.dragged_index]
        handle['cx'], handle['cy'] = new_pos.x, new_pos.y
        self.widget.waypoints[self.dragged_index] = new_pos

    def mouseDownHandle(self, decorator_id, ev):
        self.dragged_index = decorator_id
        self.drag_start = getMousePos(ev)
        self.initial_pos = self.widget.waypoints[decorator_id]
        current = ev.target
        current.dispatchEvent(window.CustomEvent.new("handle_drag_start", {"bubbles":True, "detail": {'router': self}}))
        ev.stopPropagation()
        ev.preventDefault()

    def deleteWaypoint(self):
        if self.dragged_index is not None and self.dragged_index < len(self.widget.waypoints):
            self.widget.waypoints.pop(self.dragged_index)
            self.clear_decorations()
            self.decorate(self.widget, self.widget.canvas)

    def decorate(self, connection, canvas):
        self.widget = connection
        self.decorators = [svg.circle(cx=p.x, cy=p.y, r=5, stroke_width=0, fill="#29B6F2") for p in self.widget.waypoints]
        def bind(i, d):
            d.bind('mousedown', lambda ev: self.mouseDownHandle(i, ev))
        for i, d in enumerate(self.decorators):
            canvas <= d
            # Python shares variables inside a for loop by reference
            # So to avoid binding to the same handle x times, we need to call a function to make permanent copies.
            bind(i, d)

    def clear_decorations(self):
        for d in self.decorators:
            d.remove()
        self.decorators = []

    def route(self, shape, all_blocks):
        # Determine the centers of both blocks
        c_a = shape.start.getCenter()
        c_b = shape.finish.getCenter()

        # Get the points where the line intersects both blocks
        i_a = shape.start.getIntersection(c_b if not shape.waypoints else shape.waypoints[0])
        i_b = shape.finish.getIntersection(c_a if not shape.waypoints else shape.waypoints[-1])

        # Move the line
        waypoints = ''.join(f'L {p.x} {p.y} ' for p in shape.waypoints)
        shape.path['d'] = f"M {i_a.x} {i_a.y} {waypoints}L {i_b.x} {i_b.y}"
        shape.selector['d'] = f"M {i_a.x} {i_a.y} {waypoints}L {i_b.x} {i_b.y}"

        # Store the actual intersection points
        shape.terminations = (i_a, i_b)


class RouteSquare(RoutingStragegy):
    def __init__(self):
        self.decorators = []
        self.dragged_index = None
    def mouseDownHandle(self, decorator_id, ev):
        self.dragged_index = decorator_id
        self.drag_start = getMousePos(ev)
        current = ev.target
        current.dispatchEvent(window.CustomEvent.new("handle_drag_start", {"bubbles":True, "detail": {'router': self}}))
        ev.stopPropagation()
        ev.preventDefault()
    def createWaypointByDrag(self, ev, connection, canvas):
        # WIth this router, new line segments are created differenly.
        pass
    def dragHandle(self, ev):
        wp_index = self.handle_wp_index[self.dragged_index]
        # Create a new waypoint if necessary
        if (new := math.ceil(wp_index)) != wp_index:
            # We need to create a new waypoint
            if self.handle_orientation[self.dragged_index] == 'X':
                waypoint = Point(x=self.widget.points[self.dragged_index].x, y=inf)
            else:
                waypoint = Point(x=inf, y=self.widget.points[self.dragged_index].y)
            self.widget.waypoints.insert(new, waypoint)
            self.handle_wp_index = self.getHandleWpIndices(self.widget.waypoints, self.widget.points)
            wp_index = new
        # Now we can start moving the waypoint.
        delta = getMousePos(ev) - self.drag_start
        new_pos = self.initial_pos[self.dragged_index] + delta
        h = self.decorators[self.dragged_index]
        if self.widget.waypoints[wp_index].x == inf:
            self.widget.waypoints[wp_index].y = new_pos.y
            h['y1'] = int(self.original_handle_pos[self.dragged_index][0].y + delta.y)
            h['y2'] = int(self.original_handle_pos[self.dragged_index][0].y + delta.y)
        else:
            self.widget.waypoints[wp_index].x = new_pos.x
            h['x1'] = int(self.original_handle_pos[self.dragged_index][0].x + delta.x)
            h['x2'] = int(self.original_handle_pos[self.dragged_index][0].x + delta.x)

    def dragEnd(self, canvas):
        self.clear_decorations()
        self.decorate(self.widget, canvas)

    def deleteWaypoint(self):
        wp_index = self.handle_wp_index[self.dragged_index]
        if (new := math.ceil(wp_index)) != wp_index:
            # There is no waypoint associated with this handle
            return
        self.widget.waypoints.pop(wp_index)
        self.clear_decorations()

    @staticmethod
    def getHandleWpIndices(waypoints, points):
        if not waypoints:
            return [-0.5 for _ in points[:-1]]

        current_wp_index = 0
        indices = []
        for p in points[:-1]:
            if current_wp_index >= len(waypoints):
                indices.append(len(waypoints)-0.5)
                continue
            wp = waypoints[current_wp_index]
            if wp.x == inf:
                if wp.y == p.y:
                    indices.append(current_wp_index)
                    current_wp_index += 1
                else:
                    indices.append(current_wp_index-0.5)
            else:
                if wp.x == p.x:
                    indices.append(current_wp_index)
                    current_wp_index += 1
                else:
                    indices.append(current_wp_index-0.5)
        return indices

    def decorate(self, connection, canvas):
        def bind(i, d):
            d.bind('mousedown', lambda ev: self.mouseDownHandle(i, ev))
        # Show a little stripe next to each line-piece
        self.decorators = []
        self.initial_pos = {}
        self.widget = connection
        self.handle_orientation = []
        self.handle_wp_index = self.getHandleWpIndices(self.widget.waypoints, self.widget.points)
        self.original_handle_pos = []
        for p1, p2 in zip(self.widget.points[:-1], self.widget.points[1:]):
            v = (p2 - p1)
            vn = v / len(v)
            c = (p1 + p2) / 2
            n = vn.transpose()
            self.handle_orientation.append('X' if abs(n.x) > abs(n.y) else 'Y')
            p1 = c + 10 * n - 20 * vn
            p2 = c + 10 * n + 20 * vn
            self.original_handle_pos.append((p1, p2))
            decorator = svg.line(x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y, stroke_width=6, stroke="#29B6F2")
            bind(len(self.decorators), decorator)
            self.initial_pos[len(self.decorators)] = c
            canvas <= decorator
            self.decorators.append(decorator)

    def clear_decorations(self):
        for d in self.decorators:
            d.remove()
        self.decorators = []

    def route(self, shape, all_blocks):
        # The actual algorithm for routing squared paths is quite complicated.
        # Therefore it is delegated to a separate function.
        shape.points = routeSquare((shape.start.getPos(), shape.start.getSize()),
                                   (shape.finish.getPos(), shape.finish.getSize()),
                                   shape.waypoints)

        waypoints = ''.join(f'L {p.x} {p.y} ' for p in shape.points[1:])
        start, end = shape.points[0], shape.points[-1]
        shape.path['d'] = f"M {start.x} {start.y} {waypoints}"
        shape.selector['d'] = f"M {start.x} {start.y} {waypoints}"
        shape.terminations = (start, end)


router_classes = {RoutingMethod.CenterTCenter: RouteCenterToCenter, RoutingMethod.Squared: RouteSquare}

@dataclass
class Relationship(Styled('linestyle linewidth linecolor startarrow endarrow font fontsize textcolor')):
    start: Point
    finish: Point
    waypoints: List[Point]
    routing_method: RoutingMethod
    id: HIDDEN(int) = field(default_factory=getId)

    @property
    def canvas(self):
        return self.diagram.canvas

    def onHover(self):
        pass

    def onDrag(self):
        pass

    def getMenu(self):
        pass

    def onMouseDown(self, ev):
        self.diagram.mouseDownConnection(self, ev)

    def insertWaypoint(self, pos):
        # Find the spot to insert the waypoint.
        # We insert it where the distance to the line between the two adjacent points is smallest
        allpoints = [self.terminations[0]] + self.waypoints + [self.terminations[1]]
        adjacents = zip(allpoints[:-1], allpoints[1:])
        distances = []
        for a, b in adjacents:
            v = b - a
            vmin = a - b
            n = Point(x=v.y, y=-v.x)
            d1 = pos - a
            d2 = pos - b
            # Check if the point is "behind" the segment
            # These we give infinite distance
            if v.dot(d1) < 0 or vmin.dot(d2) < 0:
                distances.append(math.inf)
            else:
                distances.append(abs(n.dot(d1)))
        # Find the smallest distance
        minimum = min(distances)
        index = distances.index(minimum)
        self.waypoints.insert(index, pos)
        return index

    def reroute(self, all_blocks):
        router = getattr(self, 'router', None) or router_classes[self.routing_method]()
        router.route(self, all_blocks)
        self.router = router

    def route(self, diagram, all_blocks):
        """ The default routing is center-to-center. """
        self.diagram = diagram
        # Create the line
        self.path = svg.path(d="", stroke="black", stroke_width="2", marker_end="url(#endarrow)",
                             marker_start="url(#startarrow)", fill="none")
        # Above the visible path, there is an invisible one used to give a wider selection region.
        self.selector = svg.path(d="", stroke="gray", stroke_width="10", fill="none", opacity="0.0")
        self.reroute(all_blocks)
        self.path.bind('mousedown', self.onMouseDown)
        self.selector.bind('mousedown', self.onMouseDown)
        self.diagram.canvas <= self.selector
        self.diagram.canvas <= self.path

    def delete(self):
        self.selector.remove()
        self.path.remove()
