
from browser import ajax, console
import json
from dataclasses import is_dataclass, asdict, fields
from typing import Any, Dict
import enum

class ExtendibleJsonEncoder(json.JSONEncoder):
    """ A JSON encoder that supports dataclasses and implements a protocol for customizing
        the generation process.
    """
    def default(self, o):
        """ We have three tricks to jsonify objects that are not normally supported by JSON.
            * Dataclass instances are serialised as dicts.
            * For objects that define a __json__ method, that method is called for serialisation.
            * For other objects, the str() protocol is used, i.e. the __str__ method is called.
        """
        if hasattr(o, '__json__'):
            return o.__json__()
        if is_dataclass(o):
            result = asdict(o)
            result['__classname__'] = type(o).__name__
            return result
        if isinstance(o, enum.Enum):
            return int(o)
        if isinstance(o, bytes):
            return o.decode('utf8')
        return str(o)


class RestApi:
    """ A standard REST API that can easily be customized.
        Also allows clients to subscribe to and distribute events.
    """
    def __init__(self):
        self.subscriptions = {}
        self.records = {}
    def get_many_url(self):
        """ Method to retried the URL for getting the collection this API interacts with. """
        raise NotImplementedError
    def get_classes(self) -> Dict[str, Any]:
        """ Get the classes that the API needs to support. Used when de-serializing. """
        raise NotImplementedError
    def get_elements_async(self, cb):
        """ Get the collection from the server. """
        def on_data(data):
            records = []
            for d in data.json:
                cls = self.get_classes()[d['__classname__']]
                ddict = {k :v for k, v in d.items() if k != '__classname__'}
                records.append(cls(**ddict))
            self.records = {r.Id: r for r in records}
            cb(self.records)
        ajax.get(self.get_many_url(), mode="json", oncomplete=on_data)
    def add_element(self, details: Any):
        """ Persist a new element """
        data = json.dumps(details, cls=ExtendibleJsonEncoder)
        def on_complete(update):
            details.Id = update.json['Id']
            self.records[details.Id] = details
        ajax.post(f'/data/{type(details).__name__}', blocking=True, data=data, oncomplete=on_complete,
                  mode='json', headers={"Content-Type": "application/json"})
    def delete_element(self, details: Any) -> bool:
        """ Called when an element is deleted.
            Returns True if the delete was successful, false if not.
        """
        result = False
        def oncomplete(response):
            nonlocal result
            if response.status >= 200 and response.status < 300:
                result = True
        ajax.delete(f'/data/{type(details).__name__}/{details.Id}', blocking=True, oncomplete=oncomplete)
        return result
    def update_element(self, details: Any):
        """ Update an existing element. """
        jstr = json.dumps(details, cls=ExtendibleJsonEncoder)
        ajax.post(f'/data/{type(details).__name__}/{details.Id}', blocking=True, data=jstr,
                  mode='json', headers={"Content-Type": "application/json"})
    def trigger_event(self, event_name, **details):
        for subs in self.subscriptions.get(event_name, []):
            subs(**details)
    def bind(self, event_name, cb):
        subs = self.subscriptions.setdefault(event_name, [])
        subs.append(cb)



class ExplorerApi(RestApi):
    """ A straight-forward API to interact with a database mirroring the entities shown in the explorer. """
    def __init__(self, allowed_children, explorer_classes):
        super().__init__()
        self.allowed_children = allowed_children
        self.explorer_classes = explorer_classes
    def get_many_url(self):
        return '/data/hierarchy'
    def get_classes(self):
        return self.explorer_classes
    def get_allowed_children(self, id: int):
        element = self.records[id]
        cls = type(element)
        return self.allowed_children[cls]
    def get_elements_async(self, cb):
        def on_data(records):
            # Determine the actual hierarchy.
            for r in records.values():
                r.children = []
            roots = []
            for r in records.values():
                if r.parent:
                    records[r.parent].children.append(r)
                else:
                    roots.append(r)
            self.hierarchy = roots
            cb(self.hierarchy)
        RestApi.get_elements_async(self, on_data)
    def add_element(self, details):
        """ Persist a new element created with the right-click menu """
        RestApi.add_element(self, details)
        parent = self.records[details.parent]
        parent.children.append(details)


class DiagramApi(RestApi):
    """ Specialized API for supporting diagrams.
        One complication in diagrams is that diagrams draw representations of classes stored in the model.
        The database will differentiate between the representations and the underlying classes.
        For the representation, only graphical details are stored (position, size etc).
        Other details are stored in the underlying class (name, description, settings, etc).
        This API needs to determine when to create or update the underlying class, and when to update
        the representation.
    """
    def __init__(self, diagram_id, explorer_classes, representation_classes, explorer_api):
        super().__init__()
        self.diagram_id = diagram_id
        self.explorer_classes = explorer_classes
        self.representation_classes = representation_classes
        self.explorer_api: ExplorerApi = explorer_api
    def get_elements_async(self, cb):
        """ Retrieve a list of elements.

            The elements of the diagram are returned as a list of (Representation, underlying entity) pairs.
            For the diagram, these are combined in one.
        """
        def on_data(response):
            if response.status >=200 and response.status < 300:
                records = []
                entity_lu = {}
                # First handle all the entities in the diagram
                for d in [r for r in response.json if 'block_cls' in r]:
                    ddict = {}
                    ddict.update(d['_entity'])
                    ddict.update(d)
                    cls = self.representation_classes[d['block_cls']]
                    field_names = [f.name for f in fields(cls)]
                    ddict = {k:v for k, v in ddict.items() if k in field_names}
                    entity = cls(**ddict)
                    records.append(entity)
                    entity_lu[entity.Id] = entity

                # Then handle the relationships
                for d in [r for r in response.json if 'rel_cls' in r]:
                    # Some underlying data needs to be reconstructed
                    ddict = {}
                    ddict.update(d['_entity'])
                    ddict.update(d)
                    cls = self.representation_classes[d['rel_cls']]
                    field_names = [f.name for f in fields(cls)]
                    ddict = {k:v for k, v in ddict.items() if k in field_names}
                    ddict['waypoints'] = json.loads(d['routing'])
                    ddict['start'] = entity_lu[d['source_repr_id']]
                    ddict['finish'] = entity_lu[d['target_repr_id']]
                    relation = cls(**ddict)
                    records.append(relation)

                console.log(f'Records: {records}')
                cb(records)
        ajax.get(f'/data/diagram_contents/{self.diagram_id}', mode='json', oncomplete=on_data)
    def add_element(self, details: Any):
        """ Persist a new element created with the right-click menu.
            In the database there is a distinction between the logical model, and the graphic representation
            of these models. The "details" class that is given as parameter combines these two aspects,
            this function needs to split them.
        """
        name = type(details).__name__
        if not name.endswith('Representation'):
            return
        # Determine which class holds the model information, instead of the graphical information.
        logical_cls = details.logical_class
        # Connections store different information than blocks or messages, so these are treated differently here.
        if details.repr_category() == 'block':
            if not details.block:
                # The block itself is new, create it first.
                new_block = logical_cls(**{k:v for k, v in asdict(details).items() if hasattr(logical_cls, k)})
                new_block.parent = self.diagram_id
                RestApi.add_element(self, new_block)
                details.block = new_block.Id

            representation = dict(
                diagram = self.diagram_id,
                block = details.block,
                x = details.x,
                y = details.y,
                z = details.z,
                width = details.width,
                height = details.height,
                styling = details.styling,
                block_cls = type(details).__name__
            )
            url =f'/data/_BlockRepresentation'
        elif details.repr_category() == 'relationship':
            if not details.relationship:
                # The block itself is new, create it first.
                new_rel = logical_cls(**{k:v for k, v in asdict(details).items() if hasattr(logical_cls, k)})
                new_rel.source = details.start.Id
                new_rel.target = details.finish.Id
                RestApi.add_element(self, new_rel)
                details.relationship = new_rel.Id

            representation = dict(
                diagram = self.diagram_id,
                relationship = details.relationship,
                source_repr_id = details.start.Id,
                target_repr_id = details.finish.Id,
                routing = json.dumps(details.waypoints),
                z = details.z,
                styling = details.styling,
                rel_cls = type(details).__name__
            )
            url =f'/data/_RelationshipRepresentation'
        else:
            raise RuntimeError(f"Category {details.repr_category()} is not (yet) supported")
        def on_complete(update):
            if update.status > 299:
                console.alert("Block could not be created")
            else:
                # Set the ID of the object that was added.
                details.Id = update.json['Id']

        data = json.dumps(representation)
        ajax.post(url, blocking=True, data=data, oncomplete=on_complete,
                  mode='json', headers={"Content-Type": "application/json"})

    def delete_element(self, details: Any) -> bool:
        """ Called when an element is deleted.
            Returns True if the delete was successful, false if not.
        """
        result = False

        def oncomplete(response):
            nonlocal result
            if response.status >= 200 and response.status < 300:
                result = True

        entity = {
            'block': '_BlockRepresentation',
            'relationship': '_RelationshipRepresentation'
        }[details.repr_category()]

        ajax.delete(f'/data/{entity}/{details.Id}', blocking=True, oncomplete=oncomplete)
        return result
    def update_element(self, details: Any):
        """ Update the representation of an object. """
        default_style = details.getDefaultStyle()
        styling_update = {k: v for k, v in details.getAllStyle().items() if default_style[k] != v}
        if details.repr_category() == 'block':
            update = dict(
                x = details.x,
                y = details.y,
                z = details.z,
                width = details.width,
                height = details.height,
                styling = styling_update,
            )
            url = f'/data/_BlockRepresentation/{details.Id}'
        elif details.repr_category() == 'relationship':
            update = dict(
                routing = json.dumps(details.waypoints),
                z = details.z,
                styling = styling_update,
            )
            url = f'/data/_BlockRepresentation/{details.Id}'
        else:
            raise RuntimeError(f"Category {details.repr_category()} is not (yet) supported")
        def on_complete(update):
            if update.status > 299:
                console.alert("Block could not be updated")
        data = json.dumps(update)
        ajax.post(url, blocking=True, data=data, oncomplete=on_complete,
            mode='json', headers={"Content-Type": "application/json"})

        # Check if the underlying entity needs to be updated.
        if details.repr_category() == 'block':
            # Retrieve the buffered copy of the block.
            entity = self.explorer_api.records[details.block]
        elif details.repr_category() == 'relationship':
            entity = self.explorer_api.records[details.relationship]

        # Determine which fields have been updated, if any
        d = asdict(details)
        entity_update = {k: getattr(details, k, v)
                        for k, v in asdict(entity).items()
                        if k not in ['Id', 'parent', 'order', 'children', 'source', 'target'] and v != d[k]}
        # If any fields were updated, persist that change.
        if entity_update:
            for k, v in entity_update.items():
                setattr(entity, k, v)
                self.explorer_api.update_element(entity)
