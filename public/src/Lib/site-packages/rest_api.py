
from browser import ajax
import json
from dataclasses import is_dataclass, asdict
from typing import Any, Dict

class ExtendibleJsonEncoder(json.JSONEncoder):
    """ A JSON encoder that supports dataclasses and implements a protocol for customizing
        the generation process.
    """
    def default(self, o):
        """ We have three tricks to jsonify objects that are not normally supported by JSON.
            * Dataclass instances are serialised as dicts.
            * For objects that define a __json__ method, that method is called for serialisation.
            * For other objects, the str() protocol is used, i.e. the __str__ method is called.
        """
        if hasattr(o, '__json__'):
            return o.__json__()
        if is_dataclass(o):
            result = asdict(o)
            result['__classname__'] = type(o).__name__
            return result
        return str(o)


class RestApi:
    """ A standard REST API that can easily be customized.
        Also allows clients to subscribe to and distribute events.
    """
    def __init__(self):
        self.subscriptions = {}
        self.records = {}
    def get_many_url(self):
        """ Method to retried the URL for getting the collection this API interacts with. """
        raise NotImplementedError
    def get_classes(self) -> Dict[str, Any]:
        """ Get the classes that the API needs to support. Used when de-serializing. """
        raise NotImplementedError
    def get_elements_async(self, cb):
        """ Get the collection from the server. """
        def on_data(data):
            records = []
            for d in data.json:
                cls = self.get_classes()[d['__classname__']]
                ddict = {k :v for k, v in d.items() if k != '__classname__'}
                records.append(cls(**ddict))
            self.records = {r.Id: r for r in records}
            cb(self.records)
        ajax.get(self.get_many_url(), mode="json", oncomplete=on_data)
    def add_element(self, details: Any):
        """ Persist a new element """
        data = json.dumps(details, cls=ExtendibleJsonEncoder)
        def on_complete(update):
            details.Id = update.json['Id']
            self.records[details.Id] = details
        ajax.post(f'/data/{type(details).__name__}', blocking=True, data=data, oncomplete=on_complete,
                  mode='json', headers={"Content-Type": "application/json"})
    def delete_element(self, details: Any) -> bool:
        """ Called when an element is deleted.
            Returns True if the delete was successful, false if not.
        """
        result = False
        def oncomplete(response):
            nonlocal result
            if response.status >= 200 and response.status < 300:
                result = True
        ajax.delete(f'/data/{type(details).__name__}/{details.Id}', blocking=True, oncomplete=oncomplete)
        return result
    def update_element(self, details: Any):
        """ Update an existing element. """
        jstr = json.dumps(details, cls=ExtendibleJsonEncoder)
        ajax.post(f'/data/{type(details).__name__}/{details.Id}', blocking=True, data=jstr,
                  mode='json', headers={"Content-Type": "application/json"})
    def trigger_event(self, event_name, **details):
        for subs in self.subscriptions.get(event_name, []):
            subs(**details)
    def bind(self, event_name, cb):
        subs = self.subscriptions.setdefault(event_name, [])
        subs.append(cb)

