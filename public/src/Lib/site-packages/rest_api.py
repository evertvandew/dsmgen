
from browser import ajax, console
import json
from dataclasses import is_dataclass, asdict
from typing import Any, Dict

class ExtendibleJsonEncoder(json.JSONEncoder):
    """ A JSON encoder that supports dataclasses and implements a protocol for customizing
        the generation process.
    """
    def default(self, o):
        """ We have three tricks to jsonify objects that are not normally supported by JSON.
            * Dataclass instances are serialised as dicts.
            * For objects that define a __json__ method, that method is called for serialisation.
            * For other objects, the str() protocol is used, i.e. the __str__ method is called.
        """
        if hasattr(o, '__json__'):
            return o.__json__()
        if is_dataclass(o):
            result = asdict(o)
            result['__classname__'] = type(o).__name__
            return result
        return str(o)


class RestApi:
    """ A standard REST API that can easily be customized.
        Also allows clients to subscribe to and distribute events.
    """
    def __init__(self):
        self.subscriptions = {}
        self.records = {}
    def get_many_url(self):
        """ Method to retried the URL for getting the collection this API interacts with. """
        raise NotImplementedError
    def get_classes(self) -> Dict[str, Any]:
        """ Get the classes that the API needs to support. Used when de-serializing. """
        raise NotImplementedError
    def get_elements_async(self, cb):
        """ Get the collection from the server. """
        def on_data(data):
            records = []
            for d in data.json:
                cls = self.get_classes()[d['__classname__']]
                ddict = {k :v for k, v in d.items() if k != '__classname__'}
                records.append(cls(**ddict))
            self.records = {r.Id: r for r in records}
            cb(self.records)
        ajax.get(self.get_many_url(), mode="json", oncomplete=on_data)
    def add_element(self, details: Any):
        """ Persist a new element """
        data = json.dumps(details, cls=ExtendibleJsonEncoder)
        def on_complete(update):
            details.Id = update.json['Id']
            self.records[details.Id] = details
        ajax.post(f'/data/{type(details).__name__}', blocking=True, data=data, oncomplete=on_complete,
                  mode='json', headers={"Content-Type": "application/json"})
    def delete_element(self, details: Any) -> bool:
        """ Called when an element is deleted.
            Returns True if the delete was successful, false if not.
        """
        result = False
        def oncomplete(response):
            nonlocal result
            if response.status >= 200 and response.status < 300:
                result = True
        ajax.delete(f'/data/{type(details).__name__}/{details.Id}', blocking=True, oncomplete=oncomplete)
        return result
    def update_element(self, details: Any):
        """ Update an existing element. """
        jstr = json.dumps(details, cls=ExtendibleJsonEncoder)
        ajax.post(f'/data/{type(details).__name__}/{details.Id}', blocking=True, data=jstr,
                  mode='json', headers={"Content-Type": "application/json"})
    def trigger_event(self, event_name, **details):
        for subs in self.subscriptions.get(event_name, []):
            subs(**details)
    def bind(self, event_name, cb):
        subs = self.subscriptions.setdefault(event_name, [])
        subs.append(cb)



class ExplorerApi(RestApi):
    """ A straight-forward API to interact with a database mirroring the entities shown in the explorer. """
    def __init__(self, allowed_children, explorer_classes):
        super().__init__()
        self.allowed_children = allowed_children
        self.explorer_classes = explorer_classes
    def get_many_url(self):
        return '/data/hierarchy'
    def get_classes(self):
        return self.explorer_classes
    def get_allowed_children(self, id: int):
        element = self.records[id]
        cls = type(element)
        return self.allowed_children[cls]
    def get_elements_async(self, cb):
        def on_data(records):
            # Determine the actual hierarchy.
            for r in records.values():
                r.children = []
            roots = []
            for r in records.values():
                if r.parent:
                    records[r.parent].children.append(r)
                else:
                    roots.append(r)
            self.hierarchy = roots
            cb(self.hierarchy)
        RestApi.get_elements_async(self, on_data)
    def add_element(self, details):
        """ Persist a new element created with the right-click menu """
        RestApi.add_element(self, details)
        parent = self.records[details.parent]
        parent.children.append(details)


class DiagramApi(RestApi):
    """ Specialized API for supporting diagrams.
        One complication in diagrams is that diagrams draw representations of classes stored in the model.
        The database will differentiate between the representations and the underlying classes.
        For the representation, only graphical details are stored (position, size etc).
        Other details are stored in the underlying class (name, description, settings, etc).
        This API needs to determine when to create or update the underlying class, and when to update
        the representation.
    """
    def __init__(self, diagram_id, blockrepr_base, explorer_classes, diagram_classes):
        super().__init__()
        self.diagram_id = diagram_id
        self.blockrepr_base = blockrepr_base
        self.explorer_classes = explorer_classes
        self.diagram_classes = diagram_classes
    def get_classes(self):
        return self.diagram_classes
    def get_elements_async(self, cb):
        """ Retrieve a list of elements.
            Some of these elements can have children, representing a hierarchy
        """
        def on_data(response):
            if response.status >=200 and response.status < 300:
                records = []
                for d in response.json:
                    cls = globals()[d['__classname__']]
                    ddict = {k:v for k, v in d.items() if k != '__classname__'}
                    records.append(cls(**ddict))
                cb(records)
        ajax.get(f'/data/diagram_contents/{self.diagram_id}', mode='json', oncomplete=on_data)
    def add_element(self, details: Any):
        """ Persist a new element created with the right-click menu """
        name = type(details).__name__
        if not name.endswith('Representation'):
            return
        block_cls = self.explorer_classes[name[:-len('Representation')]]
        if isinstance(details, self.blockrepr_base):
            if not details.block:
                # The block itself is new, create it first.
                new_block = block_cls(**{k:v for k, v in asdict(details).items() if hasattr(block_cls, k)})
                new_block.parent = self.diagram_id
                RestApi.add_element(self, new_block)
                details.block = new_block.Id

            representation = dict(
                diagram = self.diagram_id,
                block = details.block,
                x = details.x,
                y = details.y,
                z = details.z,
                width = details.width,
                height = details.height,
                styling = details.styling
            )
            def on_complete(update):
                if update.status > 299:
                    console.alert("Block could not be created")
            data = json.dumps(representation)
            ajax.post(f'/data/_BlockRepresentation', blocking=True, data=data, oncomplete=on_complete,
                mode='json', headers={"Content-Type": "application/json"})
        else:
            raise NotImplementedError
    def delete_element(self, details: Any) -> bool:
        """ Called when an element is deleted.
            Returns True if the delete was successful, false if not.
        """
        raise NotImplementedError
    def update_element(self, details: Any):
        """ Update the representation of an object. """
        if isinstance(details, self.blockrepr_base):
            update = dict(
                x = details.x,
                y = details.y,
                z = details.z,
                width = details.width,
                height = details.height,
                styling = details.styling,
            )
            def on_complete(update):
                if update.status > 299:
                    console.alert("Block could not be updated")
            data = json.dumps(update)
            ajax.post(f'/data/_BlockRepresentation/{details.Id}', blocking=True, data=data, oncomplete=on_complete,
                mode='json', headers={"Content-Type": "application/json"})
    def trigger_event(self, event_name, details):
        """ Called when an element was left-clicked. """
        raise NotImplementedError
