""" The central repository of all data.

It interfaces with the REST interface of the server.
It has a buffer for all data items that are used in the application.
"""
import json
from copy import deepcopy
from dataclasses import dataclass, is_dataclass, asdict, fields
from typing import Dict, Callable, List, Any, Iterable
from enum import Enum

from browser import ajax, console

class Collection(Enum):
    hierarchy = 'hierarchy'
    block = 'block'
    relation = 'relation'
    block_repr = 'block_repr'
    relation_repr = 'relation_repr'

    @classmethod
    def representations(cls):
        return [cls.block_repr, cls.relation_repr]

    @classmethod
    def oppose(cls, c):
        """ Find the representation collection for a model collection, and the reverse. """
        return {
            cls.block: cls.block_repr,
            cls.block_repr: cls.block,
            cls.relation: cls.relation_repr,
            cls.relation_repr: cls.relation,
        }[c]

@dataclass
class DataConfiguration:
    hierarchy_elements: Dict[str, type]
    block_entities: Dict[str, type]
    relation_entities: Dict[str, type]
    port_entities: Dict[str, type]
    block_representations: Dict[str, type]
    relation_representations: Dict[str, type]
    port_representations: Dict[str, type]
    base_url: str

    def __post_init__(self):
        result = {}
        result.update(self.hierarchy_elements)
        result.update(self.relation_entities)
        result.update(self.block_representations)
        result.update(self.relation_representations)
        result.update(self.port_representations)
        self.all_classes = result

    def get_collection(self, name):
        # Ports are categorized as blocks, to allow connections to be made to them.
        if not isinstance(name, str):
            name = type(name).__name__
        if name in self.block_entities or name in self.port_entities:
            return Collection.block
        if name in self.relation_entities:
            return Collection.relation
        if name in self.block_representations or name in self.port_representations:
            return Collection.block_repr
        if name in self.relation_representations:
            return Collection.relation_repr
        # Hierarchy already contains block + relations + ports, only diagrams + modelitems are new
        # Because there is overlap with other collections, do this one last.
        if name in self.hierarchy_elements:
            return Collection.hierarchy


class ExtendibleJsonEncoder(json.JSONEncoder):
    """ A JSON encoder that supports dataclasses and implements a protocol for customizing
        the generation process.
    """
    def default(self, o):
        """ We have three tricks to jsonify objects that are not normally supported by JSON.
            * Dataclass instances are serialised as dicts.
            * For objects that define a __json__ method, that method is called for serialisation.
            * For other objects, the str() protocol is used, i.e. the __str__ method is called.
        """
        if hasattr(o, '__json__'):
            return o.__json__()
        if is_dataclass(o):
            result = asdict(o)
            result['__classname__'] = type(o).__name__
            return result
        if isinstance(o, Enum):
            return int(o)
        if isinstance(o, bytes):
            return o.decode('utf8')
        return str(o)

def dc_from_dict(cls, ddict):
    keys = [f.name for f in fields(cls)]
    arguments = {k: v for k, v in ddict.items() if k in keys}
    return cls(**arguments)

class EventDispatcher:
    def __init__(self):
        self.subscriptions = {}
    def trigger_event(self, event_name, **details):
        for subs in self.subscriptions.get(event_name, []):
            subs(**details)
    def bind(self, event_name, cb):
        subs = self.subscriptions.setdefault(event_name, [])
        subs.append(cb)

class DataStore(EventDispatcher):
    def __init__(self, configuration: DataConfiguration):
        super().__init__()
        self.configuration = configuration
        self.cache: Dict[Collection, Dict[int: Any]] = {k: {} for k in Collection}
        self.all_classes = configuration.all_classes
        self.repr_collection_urls = {
            Collection.relation_repr: '_RelationshipRepresentation',
            Collection.block_repr: '_BlockRepresentation',
        }

    def add(self, record: Any) -> Any:
        """ Persist a new element """
        collection = self.configuration.get_collection(type(record).__name__)
        if collection in Collection.representations():
            # Representations are to be broken up into two objects:
            # Pure representation details, and the underlying model item
            assert record.diagram
            repr, model = self.split_representation_item(collection, record)
            # Check if this is a new model item (they can be created inside a diagram)
            if not model.Id:
                # Add the model item
                self.add(model)
                # Take out the new Id of the model item
                if collection == Collection.block_repr:
                    record.block = model.Id
                    repr['block'] = model.Id
                else:
                    record.relationship = model.Id
                    repr['relationship'] = model.Id
            collection_url = self.repr_collection_urls[collection]

            def on_complete(update):
                if update.status > 299:
                    console.alert("Block could not be created")
                else:
                    # Set the ID of the object that was added.
                    record.Id = update.json['Id']
                    self.update_cache(record)

            data = json.dumps(repr, cls=ExtendibleJsonEncoder)
            ajax.post(f'{self.configuration.base_url}/{collection_url}', blocking=True, data=data,
                      oncomplete=on_complete, mode='json', headers={"Content-Type": "application/json"})
            return record
        else:
            data = json.dumps(record, cls=ExtendibleJsonEncoder)
            def on_complete(update):
                record.Id = update.json['Id']
                self.update_cache(record)
            ajax.post(f'/data/{type(record).__name__}', blocking=True, data=data, oncomplete=on_complete,
                      mode='json', headers={"Content-Type": "application/json"})
            return record

    def update(self, record):
        collection = self.configuration.get_collection(record)

        def on_complete(update):
            if update.status < 300:
                self.update_cache(record)

        if collection in Collection.representations():
            # A representation is a merging of two separate entities. Treat them separately.
            repr, model = self.split_representation_item(collection, record)
            org_repr = self.cache[collection][record.Id]
            org_model = self.cache[Collection.oppose(collection)][model.Id]
            if model != org_model:
                self.update(model)
            if any(getattr(org_repr, k) != v for k, v in repr.items() if hasattr(org_repr, k) and k != 'ports'):
                url = self.repr_collection_urls[collection]
                data = json.dumps(repr, cls=ExtendibleJsonEncoder)
                ajax.post(f'{self.configuration.base_url}/{url}/{record.Id}', blocking=True, data=data,
                          oncomplete=on_complete, mode='json', headers={"Content-Type": "application/json"})
            # Handle any ports
            if collection == Collection.block_repr and hasattr(record, 'ports'):
                orig_ports = org_repr.ports
                new_ports = record.ports
                if orig_ports != new_ports:
                    lu_orig = {p.Id: p for p in orig_ports}
                    lu_new = {p.Id: p for p in new_ports}
                    deleted = set(lu_orig) - set(lu_new)
                    added = set(lu_new) - set(lu_orig)
                    updated = [i for i in (set(lu_new) & set(lu_orig)) if lu_orig[i] != lu_new[i]]

                    for i in deleted:
                        p = lu_orig[i]
                        self.delete(p)
                        # For Port representations are always directly linked to models.
                        self.delete(self.cache[Collection.block][p.block])
                    for i in added:
                        p = lu_new[i]
                        # Set fields refering to the context of the port
                        p.parent = record.Id
                        p.diagram = record.diagram
                        # Store the new port
                        self.add(p)
                    for i in updated:
                        self.update(lu_new[i])
                    self.update_cache(record)
        else:
            original = self.cache[collection][record.Id]
            if record != original:
                data = json.dumps(record, cls=ExtendibleJsonEncoder)
                ajax.post(f'{self.configuration.base_url}/{type(record).__name__}/{record.Id}', blocking=True,
                          data=data, oncomplete=on_complete, mode='json', headers={"Content-Type": "application/json"})


    def delete(self, record):
        collection = self.configuration.get_collection(record)
        def on_complete(update):
            if update.status < 300:
                del self.cache[collection][record.Id]
        url = type(record).__name__ if collection not in Collection.representations() else \
            self.repr_collection_urls[collection]
        ajax.delete(f'{self.configuration.base_url}/{url}/{record.Id}', blocking=True, oncomplete=on_complete)

    def get(self, collection: Collection, Id: int):
        # Check if the record is in the cache
        if r:=self.cache[collection].get(Id, False):
            return r
        # Cache miss. Retrieve the item from the REST API.
        raise NotImplementedError()

    def get_hierarchy(self, cb: Callable):
        def on_data(data):
            records = self.make_objects(data)
            self.update_cache(records)
            # Determine the actual hierarchy.
            lu = {}
            for r in records:
                r.children = []
                lu[r.Id] = r
            roots = []
            for r in records:
                if r.parent:
                    lu[r.parent].children.append(r)
                else:
                    roots.append(r)
            cb(roots)
        ajax.get('/data/hierarchy', mode="json", oncomplete=on_data)

    def get_diagram_data(self, diagram_id, cb: Callable):
        """ Retrieve a list of elements.

            The elements of the diagram are returned as a list of (Representation, underlying entity) pairs.
            For the diagram, these are combined in one.
        """

        def on_data(response):
            if response.status >= 200 and response.status < 300:
                records = []
                # Reconstruct the entities the diagram refers to and cache them
                for e in response.json:
                    model_details = e['_entity']
                    model_cls = self.all_classes[model_details['__classname__']]
                    model_item = dc_from_dict(model_cls, model_details)
                    self.update_cache(model_item)

                representations = []
                # Reconstruct all representations and cache them.
                for d in response.json:
                    if 'block_cls' in d:
                        cls = self.all_classes[d['block_cls']]
                    else:
                        cls = self.all_classes[d['rel_cls']]
                        d['start'] = d['source_repr_id']   # Needs to be replaced with the actual object later
                        d['finish'] = d['target_repr_id']  # Needs to be replaced with the actual object later
                        d['waypoints'] = json.loads(d['routing'])
                    # The representation needs stuff from both model and repr parts, combine them
                    ddict = d['_entity'].copy()
                    ddict.update(d)
                    entity = dc_from_dict(cls, ddict)
                    self.update_cache(entity)
                    representations.append(entity)

                # All blocks are yielded to the diagram
                records.extend(r for r in representations if r.repr_category() == 'block')

                # Ports are not yielded directly to the diagram, they are added to the block that owns them.
                for p in [r for r in representations if r.repr_category() == 'port']:
                    block = self.cache[Collection.block_repr][p.parent]
                    block.ports.append(p)

                # Then handle the relationships
                for d in [r for r in representations if r.repr_category() == 'relationship']:
                    # Some underlying data needs to be reconstructed
                    d.start = self.cache[Collection.block_repr][d.start]
                    d.finish = self.cache[Collection.block_repr][d.finish]
                    records.append(d)

                cb(records)

        ajax.get(f'/data/diagram_contents/{diagram_id}', mode='json', oncomplete=on_data)

    def make_objects(self, data: List[Any]):
        """ Turn a set of data into objects, ensuring all the types are correct """
        records = []
        for d in data.json:
            cls = self.all_classes[d['__classname__']]
            ddict = {k: v for k, v in d.items() if k != '__classname__'}
            records.append(cls(**ddict))
        return records

    def update_cache(self, records: List[Any]|Any):
        if isinstance(records, Iterable):
            for record in records:
                self.update_cache(record)
        else:
            record = records
            cls_name = type(records).__name__
            collection = self.configuration.get_collection(cls_name)
            self.cache[collection][record.Id] = deepcopy(record)

    def split_representation_item(self, collection, record) -> (Dict, Any):
        model_cls = record.logical_class
        if collection == Collection.block_repr:
            model = deepcopy(self.cache[Collection.oppose(collection)].get(record.block, False)) or model_cls()
            keys = {f.name for f in fields(model_cls) if hasattr(record, f.name) and f.name != 'Id'}
            for k in keys:
                if (v := getattr(record, k)) != getattr(model, k):
                    setattr(model, k, v)
            if record.parent:
                repr_parent = self.cache[Collection.block_repr][record.parent]
                model.parent = repr_parent.block
            if not model.parent:
                model.parent = record.diagram
            if record.repr_category() == 'port':
                repr = dict(
                    diagram=record.diagram,
                    parent=record.parent,
                    block=record.block,
                    orientation=int(record.orientation),
                    order=int(record.order),
                    styling=record.styling,
                    block_cls=type(record).__name__
                )
            else:
                repr = dict(
                    diagram=record.diagram,
                    block=record.block,
                    parent=record.parent,
                    x=record.x,
                    y=record.y,
                    z=record.z,
                    width=record.width,
                    height=record.height,
                    styling=record.styling,
                    block_cls=type(record).__name__
                )

        elif collection == Collection.relation_repr:
            # We work with a copy of the original to be able to check for modifications.
            # The cache can only be changed when it is actually persisted.
            model = deepcopy(self.cache[Collection.oppose(collection)].get(record.relationship, False)) or model_cls()
            keys = {f.name for f in fields(model_cls) if hasattr(record, f.name) and f.name != 'Id'}
            # Some keys get special treatment
            keys -= {'source', 'target'}
            for k in keys:
                if (v := getattr(record, k)) != getattr(model, k):
                    setattr(model, k, v)
            model.source = record.start.block
            model.target = record.finish.block
            repr = dict(
                diagram = record.diagram,
                relationship = record.relationship,
                source_repr_id = record.start.Id,
                target_repr_id = record.finish.Id,
                routing = json.dumps(record.waypoints, cls=ExtendibleJsonEncoder),
                z = record.z,
                styling = record.styling,
                rel_cls = type(record).__name__
            )
        else:
            raise NotImplementedError()
        return repr, model