"""
Tests where the Brython client is run against a simulated Brython - browser.
"""

import json
from copy import copy
import re

import data_store
import modeled_shape
from test_frame import prepare, test, run_tests
from shapes import Point
from unittest.mock import Mock, MagicMock
import diagrams
from modeled_diagram import ModeledDiagram
import explorer
from data_store import ExtendibleJsonEncoder, DataStore, DataConfiguration, Collection, StorableElement, ReprCategory
from browser.ajax import add_expected_response, Response, check_expected_response, \
    clear_expected_response
from browser import events, html, document as d
from explorer import make_explorer

from integration_context import IntegrationContext

import generate_project  # Ensures the client is built up to date

# As the client is generated by the `import generate_project`, this must be BELOW that line.
import public.sysml_client as client
import build.sysml_data as server_data


def intergration_context(hierarchy=None) -> IntegrationContext:
    return IntegrationContext(client, server_data, hierarchy)


def set_entity_ids(ids):
    def cb(entity):
        entity.Id = ids.pop(0)
        return entity

    return cb


def mk_ds():
    config = DataConfiguration(
        hierarchy_elements=client.explorer_classes,
        block_entities=client.block_entities,
        relation_entities=client.relation_classes,
        port_entities=client.port_classes,
        base_url='/data'
    )

    ds = DataStore(config)
    return ds


example_diagram = [
    {"Id": 1, "diagram": 3, "block": 4, "x": 401.0, "y": 104.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {"color": "yellow"}, "block_cls": "BlockRepresentation", "category": int(data_store.ReprCategory.block),
     "__classname__": "_BlockRepresentation",
     "_entity": {"order": 0, "Id": 4, "parent": None, "name": "Test1",
                 "description": "This is a test block",
                 "__classname__": "Block"}},
    {"Id": 2, "diagram": 3, "block": 5, "x": 369.0, "y": 345.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {}, "block_cls": "BlockRepresentation", "__classname__": "_BlockRepresentation",
     "category": int(data_store.ReprCategory.block),
     "_entity": {"order": 0, "Id": 5, "parent": 2, "name": "Test2", "description": "",
                 "__classname__": "Block"}},
    {"Id": 3, "diagram": 3, "block": 7, "x": 101.0, "y": 360.0, "z": 0.0, "width": 110.0, "height": 65.0,
     "styling": {"bordercolor": "#000000", "bordersize": "2", "blockcolor": "#fffbd6", "fold_size": "10",
                 "font": "Arial", "fontsize": "16", "textcolor": "#000000", "xmargin": 2, "ymargin": 2,
                 "halign": 11, "valign": 2}, "block_cls": "NoteRepresentation",
     "__classname__": "_BlockRepresentation",
     "category": int(data_store.ReprCategory.block),
     "_entity": {"order": 0, "Id": 7, "description": "Dit is een commentaar", "parent": 3,
                 "__classname__": "Note"}},
    {"Id": 1, "diagram": 3, "relationship": 1, "source_repr_id": 1, "target_repr_id": 2, "routing": "[]",
     "z": 0.0, "styling": {}, "rel_cls": "BlockReferenceRepresentation",
     "__classname__": '_RelationshipRepresentation',
     "_entity": {"Id": 1, "stereotype": 1, "source": 4, "target": 5, "source_multiplicity": 1,
                 "target_multiplicity": 1, "__classname__": "BlockReference"}},
    {"Id": 51, "diagram": 3, "block": 10, "parent": 2, "__classname__": "_BlockRepresentation",
     "block_cls": "FlowPortRepresentation",
     "category": int(data_store.ReprCategory.port),
     "_entity": {"Id": 10, "parent": 5, "__classname__": "FlowPort"}
     }, {
        "Id": 2, "diagram": 3, "relationship": 2, "source_repr_id": 3, "target_repr_id": 2, "routing": "[]",
        "z": 0.0, "styling": {}, "rel_cls": "BlockReferenceRepresentation",
        "__classname__": '_RelationshipRepresentation',
        "_entity": {"Id": 2, "source": 7, "target": 5, "__classname__": "Anchor"}
    }
]
port2port = [
    {"Id": 1, "diagram": 3, "block": 4, "x": 401.0, "y": 104.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {"color": "yellow"}, "block_cls": "ModeledShapeAndPorts", "parent": None,
     "__classname__": "_BlockRepresentation",
     "category": int(data_store.ReprCategory.block),
     "_entity": {"order": 0, "Id": 4, "parent": None, "name": "Test1",
                 "description": "This is a test block",
                 "__classname__": "Block"}},
    {"Id": 2, "diagram": 3, "block": 5, "x": 369.0, "y": 345.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {}, "block_cls": "ModeledShapeAndPorts", "__classname__": "_BlockRepresentation", "parent": None,
     "category": int(data_store.ReprCategory.block),
     "_entity": {"order": 0, "Id": 5, "parent": 2, "name": "Test2", "description": "",
                 "__classname__": "Block"}},
    {"Id": 3, "diagram": 3, "block": 7, "x": 101.0, "y": 360.0, "z": 0.0, "width": 110.0, "height": 65.0,
     "styling": {"bordercolor": "#000000", "bordersize": "2", "blockcolor": "#fffbd6", "fold_size": "10",
                 "font": "Arial", "fontsize": "16", "textcolor": "#000000", "xmargin": 2, "ymargin": 2,
                 "halign": 11, "valign": 2}, "block_cls": "ModeledShapeAndPorts",
     "__classname__": "_BlockRepresentation", "parent": None,
     "category": int(data_store.ReprCategory.block),
     "_entity": {"order": 0, "Id": 7, "name": "Test 3", "description": "Dit is een commentaar", "parent": 2,
                 "__classname__": "Block"}},
    {"Id": 51, "diagram": 3, "block": 10, "parent": 2, "__classname__": "_BlockRepresentation",
     "block_cls": "Port",
     "category": int(data_store.ReprCategory.port),
     "_entity": {"Id": 10, "parent": 5, "__classname__": "FlowPort"}
     },
    {"Id": 52, "diagram": 3, "block": 11, "parent": 3, "__classname__": "_BlockRepresentation",
     "block_cls": "Port",
     "category": int(data_store.ReprCategory.port),
     "_entity": {"Id": 11, "parent": 7, "__classname__": "FlowPort"}
     },
    {"Id": 1, "diagram": 3, "relationship": 1, "source_repr_id": 51, "target_repr_id": 52, "routing": "[]",
     "z": 0.0, "styling": {}, "rel_cls": "ModeledRelationship",
     '__classname__': '_RelationshipRepresentation',
     "category": int(data_store.ReprCategory.relationship),
     "_entity": {"Id": 1, "stereotype": 1, "source": 10, "target": 11, "source_multiplicity": 1,
                 "target_multiplicity": 1, "__classname__": "FlowPortConnection"}},

]

diagram_w_instance = [
    {"Id": 1, "diagram": 3, "block": 7, "parent": None, "x": 358.0, "y": 235.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {}, "block_cls": "BlockInstanceRepresentation", "__classname__": "_BlockRepresentation",
     "parameters": {"parameters": {"factor": 41, "gain": 3.1415}}, "category": int(data_store.ReprCategory.block_instance),
     "_entity": {"order": 0, "Id": 4, "parent": 1, "name": "test block", "implementation": "",
                     "parameters": {"factor": "int", "gain": "float"}, "__classname__": "SubProgramDefinition"}},
    {"Id": 2, "diagram": 3, "block": 5, "parent": 1, "x": 0.0, "y": 0.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {}, "block_cls": "FlowPortRepresentation", "__classname__": "_BlockRepresentation",
     "category": int(data_store.ReprCategory.block),
     "_entity": {"order": 0, "orientation": 8, "Id": 5, "name": "in", "parent": 4, "__classname__": "FlowPort"}},
    {"Id": 3, "diagram": 3, "block": 6, "parent": 1, "x": 0.0, "y": 0.0, "z": 0.0, "width": 64.0, "height": 40.0,
     "styling": {}, "block_cls": "FlowPortRepresentation", "__classname__": "_BlockRepresentation",
     "category": int(data_store.ReprCategory.port),
     "_entity": {"order": 0, "orientation": 4, "Id": 6, "name": "out", "parent": 4, "__classname__": "FlowPort"}}
]


@prepare
def simulated_diagram_tests():
    """ Test detailed behaviour of the diagram editor. """
    # Set the context for the diagram editor. Normally this is in the HTML file.
    from browser import document as d
    from browser import html
    d.clear()
    _ = d <= html.DIV(id='explorer')
    _ = d <= html.DIV(id='canvas')
    _ = d <= html.DIV(id='details')

    def new_diagram(diagram_id, diagram_api):
        container = d['canvas']
        container.html = ''
        svg = html.SVG()
        svg.classList.add('diagram')
        container <= svg
        config = diagrams.DiagramConfiguration(
            client.connections_from
        )
        diagram = diagrams.load_diagram(
            diagram_id,
            client.diagram_definitions['BlockDefinitionDiagram'],
            config,
            diagram_api,
            svg
        )
        return diagram, diagram_api

    @test
    def create_and_move_block():
        def create_and_move(model_entity: client.ms.ModelEntity, **repr_details):
            instance = model_entity.get_representation_cls(modeled_shape.ReprCategory.block)(model_entity=model_entity,
                                                                                             **repr_details)
            old_nr_children = len(diagram.children)
            diagram.addBlock(instance)
            assert len(diagram.children) == old_nr_children + 1

            # Simulate dragging the block
            block = diagram.children[old_nr_children]
            block.shape.dispatchEvent(events.MouseDown())
            block.shape.dispatchEvent(events.MouseMove(offsetX=200, offsetY=100))
            block.shape.dispatchEvent(events.MouseUp(offsetX=200, offsetY=100))
            assert block.x == 500
            assert block.y == 400

        # Do a normal block
        diagram, rest = new_diagram(1, MagicMock())
        create_and_move(client.Block(name='', Id=1), x=300, y=300, height=64, width=100, Id=1)

        # Add a port label representation
        create_and_move(client.FlowPort(name='', Id=1), x=300, y=300, height=64, width=100, Id=1)

        # Add a SubprogramDefinition
        create_and_move(client.SubProgramDefinition(name='', Id=1), x=300, y=300, height=64, width=100, Id=1)
        check_expected_response()

    @test
    def create_connect_blocks():
        # Connect two PortLabels: an input and an output.
        diagram, rest = new_diagram(1, MagicMock())
        entity = client.Block(Id=1, name='block')
        p1 = client.FlowPort(Id=2, parent=1, name='Input')
        p2 = client.FlowPort(Id=3, parent=1, name='Output')
        input = client.PortLabel(model_entity=p1, x=100, y=300, height=64, width=100, Id=10)
        output = client.PortLabel(model_entity=p2, x=400, y=300, height=64, width=100, Id=11)

        diagram.addBlock(input)
        diagram.addBlock(output)
        diagram.changeFSM(diagrams.ConnectionEditor())
        input.shape.dispatchEvent(events.MouseDown())
        input.shape.dispatchEvent(events.MouseUp())
        output.shape.dispatchEvent(events.MouseDown())
        output.shape.dispatchEvent(events.MouseUp())
        assert len(diagram.connections) == 1
        conn = diagram.connections[0]
        assert type(conn.model_entity).__name__ == 'FlowPortConnection'
        assert conn.start.Id == 10
        assert conn.finish.Id == 11
        check_expected_response()

    @test
    def drag_and_drop():
        ds = mk_ds()
        add_expected_response('/data/diagram_contents/5', 'get', Response(201, json=[]))
        diagram, rest = new_diagram(5, ds)
        rest.add = set_entity_ids([400])
        instance = client.Block(name='One', parent=3, Id=123)
        restif = Mock()
        restif.get_hierarchy = Mock(side_effect=lambda cb: cb([instance]))
        explorer.make_explorer(d['explorer'], restif, client.allowed_children)
        ev = events.DragStart()
        d['explorer'].select(f'.{explorer.name_cls}')[0].dispatchEvent(ev)
        assert ev.dataTransfer.data
        add_expected_response('/data/Block/123/create_representation', 'post', Response(201, json={
            'Id': 400,
            '__classname__': '_BlockRepresentation',
            'block': 123,
            'parent': None,
            'diagram': 5,
            'x': 400,
            'y': 500,
            'width': 64,
            'height': 40,
            'children': [],
            'block_cls': 'BlockRepresentation',
            'category': int(data_store.ReprCategory.block),
            '_entity': {'name': 'One', 'parent': 3, 'Id': 123, '__classname__': 'Block'},
        }))
        diagram.canvas.dispatchEvent(events.DragEnter(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.DragOver(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.DragOver(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.Drop(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.DragEnd(dataTransfer=ev.dataTransfer))
        assert diagram.children
        repr = diagram.children[0]
        assert repr.model_entity.name == 'One'
        assert repr.diagram == 5
        assert repr.model_entity.Id == 123
        assert repr.Id == 400
        check_expected_response()

    @test
    def drag_and_drop_with_ports():
        ds = mk_ds()
        add_expected_response('/data/diagram_contents/5', 'get', Response(201, json=[]))
        diagram, rest = new_diagram(5, ds)
        instance = client.Block(name='One', parent=3, Id=123)
        instance.children.append(client.FlowPort(name='output', parent=123, Id=124))
        ds.update_cache(instance)
        ds.update_cache(instance.children[0])
        restif = Mock()
        restif.get_hierarchy = Mock(side_effect=lambda cb: cb([instance]))
        explorer.make_explorer(d['explorer'], restif, client.allowed_children)
        ev = events.DragStart()
        ev.dataTransfer.data = {'entity': json.dumps(instance, cls=ExtendibleJsonEncoder)}
        add_expected_response('/data/Block/123/create_representation', 'post', Response(201, json={
            'Id': 400,
            '__classname__': '_BlockRepresentation',
            'block': 123,
            'parent': None,
            'diagram': 5,
            'x': 400,
            'y': 500,
            'width': 64,
            'height': 40,
            'block_cls': 'BlockRepresentation',
            'category': int(data_store.ReprCategory.block),
            '_entity': {'name': 'One', 'parent': 3, 'Id': 123, '__classname__': 'Block'},
            'children': [
                {
                    'Id': 401,
                    'block': 124,
                    'parent': 400,
                    'diagram': 5,
                    '__classname__': '_BlockRepresentation',
                    'block_cls': 'FlowPortRepresentation',
                    'category': int(data_store.ReprCategory.port),
                    '_entity': {'name': 'Output', 'parent': 123, 'Id': 124, '__classname__': 'FlowPort'}
                }
            ]
        }))
        diagram.canvas.dispatchEvent(events.DragEnter(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.DragOver(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.DragOver(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.Drop(dataTransfer=ev.dataTransfer))
        diagram.canvas.dispatchEvent(events.DragEnd(dataTransfer=ev.dataTransfer))
        assert diagram.children
        repr = diagram.children[0]
        assert len(repr.ports) == 1
        port = repr.ports[0]
        assert port.Id == 401
        assert port.parent == 400
        assert port.block == 124
        assert port.diagram == 5
        check_expected_response()

    @test
    def load_diagram():
        ds = mk_ds()

        add_expected_response('/data/diagram_contents/3', 'get', Response(
            200,
            json=example_diagram))
        diagram, rest = new_diagram(3, ds)
        check_expected_response()

        # Check the various elements were rendered to the DOM
        nonlocal d
        assert len(d['canvas'].select('[data-class="ModeledShapeAndPorts"]')) == 2
        assert len(d['canvas'].select('[data-class="ModeledShape"]')) == 1
        assert len(d['canvas'].select('[data-class="Port"]')) == 1
        check_expected_response()

    @test
    def connection_property_editor():
        import public.sysml_client as client
        ds = mk_ds()

        add_expected_response('/data/diagram_contents/3', 'get', Response(
            200,
            json=port2port))
        diagram, rest = new_diagram(3, ds)
        ds.subscribe('shape_selected', diagram.canvas, client.on_diagram_selection)
        connection = diagram.connections[0]
        connection.path.dispatchEvent(events.MouseDown())
        connection.path.dispatchEvent(events.MouseUp())
        check_expected_response()
        nonlocal d
        form = d.select('form')
        assert len(form) == 2
        html_form = str(form)
        assert d.select('#edit_name')
        assert d.select('#styling_linecolor')
        edit = d.select_one('form #edit_name')
        edit.value = 'Connection'
        btn = d.select_one('#details .btn-primary')

        add_expected_response('/data/FlowPortConnection/1', 'post', Response(200, json={}))
        btn.dispatchEvent(events.Click())

        live_instance = ds.get(Collection.relation, 1)
        assert live_instance.name == 'Connection'
        check_expected_response()

    @test
    def block_property_editor():
        import public.sysml_client as client
        ds = mk_ds()

        add_expected_response('/data/diagram_contents/3', 'get', Response(
            200,
            json=port2port))
        diagram, rest = new_diagram(3, ds)
        ds.subscribe('shape_selected', diagram, client.on_diagram_selection)
        block = [c for c in diagram.children if c.ports][0]
        block.shape.dispatchEvent(events.MouseDown())
        block.shape.dispatchEvent(events.MouseUp())
        check_expected_response()
        nonlocal d
        form = d.select('form')
        assert len(form) == 2
        assert d.select('#edit_name')
        assert d.select('#edit_description')
        assert d.select('.porttable TR')  # the editor for the port
        # There should be a style editor in the second form.
        assert d.select('#styling_blockcolor')
        check_expected_response()

    @test
    def handling_parameter_spec_dropped_block():
        """ Simulate dropping a block so that it is instantiated.
            Then check the proper edit fields are presented and handled.
        """
        nonlocal d
        import public.sysml_client as client
        ds = mk_ds()

        add_expected_response('/data/diagram_contents/5', 'get', Response(201, json=[]))
        diagram, rest = new_diagram(5, ds)
        ds.subscribe('shape_selected', diagram.canvas, client.on_diagram_selection)
        rest.add = set_entity_ids([400])

        definition = client.SubProgramDefinition(Id=123, name='Block 1', parent=1, description='Dit is een test',
                                                 parameters='limit:int,factor:float')
        ds.update_cache(definition)

        restif = Mock()
        restif.get_hierarchy = Mock(side_effect=lambda cb: cb([definition]))
        explorer.make_explorer(d['explorer'], restif, client.allowed_children)
        ev = events.DragStart()
        ev.dataTransfer.data = {'entity': json.dumps(definition, cls=ExtendibleJsonEncoder)}

        add_expected_response('/data/BlockInstance/123/create_representation', 'post', Response(201, json={
            'Id': 400,
            '__classname__': '_BlockInstanceRepresentation',
            'category': 8,
            'block': 125,
            'parent': None,
            'diagram': 5,
            'x': 400,
            'y': 500,
            'width': 64,
            'height': 40,
            'children': [
                {
                    'Id': 401,
                    'block': 124,
                    'parent': 400,
                    'diagram': 5,
                    '__classname__': '_BlockRepresentation',
                    'block_cls': 'FlowPortRepresentation',
                    "category": int(data_store.ReprCategory.port),
                    '_entity': {'name': 'Output', 'parent': 123, 'Id': 124, '__classname__': 'FlowPort'}
                }
            ],
            'block_cls': 'BlockInstanceRepresentation',
            '_entity': definition.asdict()
        }))

        for cls in [events.DragEnter, events.DragOver, events.DragOver, events.Drop, events.DragEnd]:
            diagram.canvas.dispatchEvent(cls(dataTransfer=ev.dataTransfer))

        assert diagram.children
        repr: client.ms.ModeledShapeAndPorts = diagram.children[0]
        assert repr.diagram == 5
        assert repr.model_entity.Id == 123
        assert repr.model_entity.parent == 1
        assert repr.Id == 400
        check_expected_response()

        # Trigger the details editor.
        repr.shape.dispatchEvent(events.MouseDown())
        repr.shape.dispatchEvent(events.MouseUp())
        check_expected_response()
        form = d.select('form')
        assert len(form) == 2

        # Assert the correct edits have been created.
        assert d.select('#edit_factor')
        assert d.select('#edit_limit')
        assert not d.select('#edit_parameters')

        # Set the values and check they are stored properly.
        d.select('#edit_factor')[0].value = '123.456'
        d.select('#edit_limit')[0].value = '87654'
        btn = d.select_one('#details .btn-primary')
        add_expected_response('/data/_BlockRepresentation/400', 'post', Response(200, json={}))
        btn.dispatchEvent(events.Click())

        assert repr.parameters == {'factor': 123.456, 'limit': 87654}
        check_expected_response()

    @test
    def block_properties_editor_instance():
        """ Load a diagram with a single block: an instance with ports """
        nonlocal d
        import public.sysml_client as client
        ds = mk_ds()

        add_expected_response('/data/diagram_contents/3', 'get', Response(
            200,
            json=diagram_w_instance))
        diagram, rest = new_diagram(3, ds)
        ds.subscribe('shape_selected', diagram, client.on_diagram_selection)

        block = diagram.children[0]
        block.shape.dispatchEvent(events.MouseDown())
        block.shape.dispatchEvent(events.MouseUp())
        check_expected_response()
        form = d.select('form')
        assert len(form) == 2
        html_form = str(form)
        # There should be edit fields for the gain and the factor parameters, as specified in the parameter definitions.
        assert d.select('#edit_gain')
        assert d.select('#edit_factor')
        assert not d.select('form TR')  # There must be no editor for ports.
        # Check there is no editing of the fields in the Definition
        assert len(d.select('#edit_parameters')) == 0
        assert len(d.select('#edit_description')) == 0
        assert len(d.select('#edit_name')) == 0
        # It should be possible to edit the styling of the block.
        assert d.select('#styling_blockcolor')
        check_expected_response()

    @test
    def load_test_diagrams():
        nonlocal d
        ds = mk_ds()

        add_expected_response('/data/diagram_contents/4', 'get', Response(
            200,
            json=diagram_w_instance))
        diagram, rest = new_diagram(4, ds)
        check_expected_response()


@prepare
def simulated_explorer_tests():
    """ Test detailed behaviour of the explorer. """

    def reset_document():
        clear_expected_response()
        d.clear()
        d <= html.DIV(id='explorer')
        d <= html.DIV(id='canvas')
        d <= html.DIV(id='details')

    reset_document()

    config = DataConfiguration(
        hierarchy_elements=client.explorer_classes,
        block_entities=client.block_entities,
        relation_entities=client.relation_classes,
        port_entities=client.port_classes,
        base_url='/data'
    )

    @test
    def right_click_menu():
        ds = DataStore(config)

        clear_expected_response()
        add_expected_response('/data/hierarchy', 'get', Response(
            200,
            json=[
                {"order": 0, "Id": 1, "name": "Functional Model", "description": "", "parent": None,
                 "__classname__": "FunctionalModel"},
                {"order": 0, "Id": 2, "name": "Structural Model", "description": "", "parent": None,
                 "__classname__": "StructuralModel"},

            ]))
        make_explorer(d['explorer'], ds, client.allowed_children)
        # Get the second line in the explorer and right-click it.
        lines = d.get(selector='.eline [draggable="true"]')
        assert len(lines) == 2
        l = [l for l in lines if 'Structural' in str(l)][0]
        l.dispatchEvent(events.ContextMenu())
        # Find the option to create a new diagram
        items = list(l.select('*'))
        print(f'Len items: {len(items)} {[i.text for i in items]}')
        option = [item for item in l.select('*') if item.text == 'BlockDefinitionDiagram'][0]
        option.dispatchEvent(events.Click())
        # There should be a form to enter the name for the new diagram.
        # Enter a name and click OK
        input = d.select("#edit_name")[0]
        input.value = 'My Diagram'
        button = [b for b in d.select(".brython-dialog-main button") if b.text.lower() == 'ok'][0]
        add_expected_response('/data/BlockDefinitionDiagram', 'post', Response(201, json={'Id': 3}))
        button.dispatchEvent(events.Click())
        lines = d.get(selector='.eline [draggable="true"]')
        assert len(lines) == 3
        check_expected_response()

    @test
    def left_click():
        reset_document()
        ds = DataStore(config)

        clear_expected_response()
        add_expected_response('/data/hierarchy', 'get', Response(
            200,
            json=[
                {"order": 0, "Id": 1, "name": "Functional Model", "description": "", "parent": None,
                 "__classname__": "FunctionalModel"},
                {"order": 0, "Id": 2, "name": "Structural Model", "description": "", "parent": None,
                 "__classname__": "StructuralModel"},

            ]))
        make_explorer(d['explorer'], ds, client.allowed_children)
        blank = d['explorer']
        ds.subscribe('click', blank, client.on_explorer_click)

        # Get the second line in the explorer and left-click it.
        lines = d.get(selector='.eline [draggable="true"]')
        assert len(lines) == 2
        # Check the details editor is empty
        assert len(d.select('#details *')) == 0
        l = [l for l in lines if 'Structural' in str(l)][0]
        l.dispatchEvent(events.Click())
        # Check the details editor is not empty
        assert len(d.select('#details *')) > 0

        # Change the value of the Structural Model,
        btn = d.select_one('#details button')
        edit_fields = [i for i in d.select('#details input') if i.value == 'Structural Model']
        assert len(edit_fields) == 1
        assert edit_fields[0].value == 'Structural Model'
        edit_fields[0].value = 'blablablabla'
        add_expected_response('/data/StructuralModel/2', 'post', Response(200))
        btn.dispatchEvent(events.Click())
        check_expected_response()
        assert ds.get(Collection.hierarchy, 2).name == 'blablablabla'

    @test
    def editing_parameter_spec():
        """ Test the editor for a parameter spec. """
        # The SubProgramDefinition has a parameter spec.
        reset_document()
        ds = DataStore(config)

        clear_expected_response()
        add_expected_response('/data/hierarchy', 'get', Response(
            200,
            json=[
                {"order": 0, "Id": 1, "name": "Test block", "description": "", "parent": None,
                 "__classname__": "SubProgramDefinition"},
            ]))
        make_explorer(d['explorer'], ds, client.allowed_children)
        blank = d['explorer']
        ds.subscribe('click', blank, client.on_explorer_click)

        # Get the first line in the explorer and left-click it.
        lines = d.get(selector='.eline [draggable="true"]')
        assert len(lines) == 1
        # Check the details editor is empty
        assert len(d.select('#details *')) == 0
        l = [l for l in lines if 'Test block' in str(l)][0]
        l.dispatchEvent(events.Click())
        # Check the details editor is not empty
        assert len(d.select('#details *')) > 0
        for expected in ['edit_name', 'edit_description', 'edit_parameters']:
            assert len(d.select(f'#{expected}')) > 0, f"Expected edit {expected} not found"

        # Set the parameters field and submit the changes.
        input = d.select('#edit_parameters')[0]
        input.value = 'gain:float,factor:int'
        add_expected_response('/data/SubProgramDefinition/1', 'post', Response(200))
        btn = [b for b in d.select('#details button') if b.text == 'Save'][0]
        btn.dispatchEvent(events.Click())
        check_expected_response()

    @test
    def drag_drop():
        reset_document()
        ds = DataStore(config)

        clear_expected_response()
        add_expected_response('/data/hierarchy', 'get', Response(
            200,
            json=[
                {"order": 0, "Id": 1, "name": "Functional Model", "description": "", "parent": None,
                 "__classname__": "FunctionalModel"},
                {"order": 0, "Id": 2, "name": "Structural Model", "description": "", "parent": None,
                 "__classname__": "StructuralModel"},

            ]))
        make_explorer(d['explorer'], ds, client.allowed_children)
        blank = d['explorer']

        source = [i for i in d['explorer'].select(f'.{explorer.name_cls}') if 'Structural' in str(i)][0]
        ev = events.DragStart()
        source.dispatchEvent(ev)
        assert ev.dataTransfer.data
        target = [i for i in d['explorer'].select(f'.{explorer.name_cls}') if 'Functional' in str(i)][0]
        target.dispatchEvent(events.DragEnter(dataTransfer=ev.dataTransfer))
        target.dispatchEvent(events.DragOver(dataTransfer=ev.dataTransfer))
        target.dispatchEvent(events.DragOver(dataTransfer=ev.dataTransfer))
        target.dispatchEvent(events.Drop(dataTransfer=ev.dataTransfer))
        target.dispatchEvent(events.DragEnd(dataTransfer=ev.dataTransfer))

        # Acknowledge that a move is desired
        btns = d.select('.brython-dialog-main button')
        ok_btn = [b for b in btns if b.text.lower() == 'ok'][0]

        def get_response(url, method, kwargs):
            #data = json.loads(kwargs['data'])
            data = kwargs
            assert data['parent'] == 1
            return Response(200, json=data)

        add_expected_response('/data/StructuralModel/2', 'post', get_response=get_response)
        add_expected_response('/data/hierarchy', 'get', Response(
            200,
            json=[
                {"order": 0, "Id": 1, "name": "Functional Model", "description": "", "parent": None,
                 "__classname__": "FunctionalModel"},
                {"order": 0, "Id": 2, "name": "Structural Model", "description": "", "parent": 1,
                 "__classname__": "StructuralModel"},

            ]))
        ok_btn.dispatchEvent(events.Click())
        check_expected_response()

@prepare
def integration_tests():
    """ Test high-level behaviour of the tool. """
    from browser import document as d
    from browser import html

    TheHierarchy = [
        {"order": 0, "Id": 1, "name": "Functional Model", "description": "", "parent": None,
         "__classname__": "FunctionalModel"},
        {"order": 0, "Id": 2, "name": "Structural Model", "description": "", "parent": 1,
         "__classname__": "StructuralModel"},
        {'Id': 3, 'parent': 1, 'name': 'subprogram', '__classname__': "SubProgramDefinition"}
    ]

    @test
    def edit_subdiagram():
        context = intergration_context(hierarchy=TheHierarchy)
        assert context.explorer.count() == 3
        context.diagrams.prepare_contents({3: []})
        context.explorer.dblclick_element(mid=3)
        assert context.diagrams.count() == 1

        # Create a basic network.
        # First create the main components.
        context.diagrams.create_block(client.FlowPort)
        context.diagrams.move_block(1, (0, 100))
        context.diagrams.create_block(client.Block)
        context.diagrams.move_block(2, (300, 100))
        context.diagrams.create_block(client.FlowPort)
        context.diagrams.move_block(3, (600, 100))
        # Add two ports to the Block
        context.diagrams.add_port(2, client.FlowPort, name='in')
        context.diagrams.add_port(2, client.FlowPort, name='out')
        assert len(context.diagrams.ports(2)) == 2
        # Connect the three blocks
        context.diagrams.connect(1, (2, 0), client.FlowPortConnection)
        context.diagrams.connect((2, 1), 3, client.FlowPortConnection)
        # Check the data in the data store
        # The SubProgramDefinition should have two ports
        assert len([p for p in context.data_store.ports if p.parent == 3]) == 2
        # There should be two relationships to the block
        assert len(context.data_store.relationships) == 2
        check_expected_response()

    @test
    def edit_ports():
        """ Create a block, add ports, edit them and delete them.
            Use the property editor, check changes are reflected in the diagram.
        """
        context = intergration_context(hierarchy=[
            client.BlockDefinitionDiagram(Id=1, name="diagram").asdict(),
        ])
        # Open the diagram in the display and add a block
        add_expected_response('/data/diagram_contents/1', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=1)
        context.diagrams.create_block(client.Block)
        # Open the property editor for this block
        context.diagrams.click_block(rid=1)
        # Add a port and check it is represented
        context.property_editor.add_port(client.FlowPort, 1)
        context.property_editor.save()
        assert context.property_editor.count_ports() == 1
        assert len(context.diagrams.ports(rid=1)) == 1
        # Add another port
        context.property_editor.add_port(client.FlowPort, 1)
        context.property_editor.save()
        assert context.property_editor.count_ports() == 2
        assert len(context.diagrams.ports(rid=1)) == 2
        # Check they are in the database
        assert len(context.data_store.live_instances[Collection.block]) == 3
        assert len(context.data_store.live_instances[Collection.block_repr]) == 3
        # Delete the two ports
        context.property_editor.remove_port()
        context.property_editor.remove_port()
        context.property_editor.save()
        assert context.property_editor.count_ports() == 0
        assert len(context.diagrams.ports(rid=1)) == 0
        # Check they are no more in the database
        assert len(context.data_store.live_instances[Collection.block]) == 1
        assert not context.data_store.live_instances[Collection.block][2].ports
        assert len(context.data_store.live_instances[Collection.block_repr]) == 1
        assert not context.data_store.live_instances[Collection.block_repr][1].ports
        # Check they are in the database
        assert len(context.data_store.live_instances[Collection.block]) == 1
        assert len(context.data_store.live_instances[Collection.block_repr]) == 1
        check_expected_response()

    @test
    def edit_block_name():
        """ Create a block, edit the 'name' field.
            Use the property editor, check changes are reflected in the diagram & explorer.
        """
        context = intergration_context(hierarchy=[
            client.BlockDefinitionDiagram(Id=1, name="diagram").asdict(),
        ])
        # Open the diagram in the display and add a block
        add_expected_response('/data/diagram_contents/1', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=1)
        context.diagrams.create_block(client.Block)
        # Check the block is in the explorer as a child of the diagram
        assert context.explorer.count() == 2
        # Open the property editor for this block
        context.diagrams.click_block(rid=1)
        # Change the name and save it.
        name = 'test block'
        context.property_editor.set_field(name=name)
        add_expected_response('/data/Block/2', 'post', Response(200, json=[]))
        context.property_editor.save()
        assert context.diagrams.block_text(rid=1) == name
        assert context.explorer.name(mid=2) == name
        check_expected_response()

    @test
    def edit_definition_and_instance():
        """ Test that an instance represented in a diagram reacts to changes in the underlying model. """
        # We start with an instantiatable element with a port and a diagram.
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=1, name="Library_block").asdict(),
            client.FlowPort(Id=2, name="in", parent=1).asdict(),
            client.BlockDefinitionDiagram(Id=3, name="diagram").asdict()
        ])
        # Open the diagram in the display and add a library block
        add_expected_response('/data/diagram_contents/3', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=3)
        context.explorer.drag_to_diagram(mid=1, drop_cls=client.BlockInstance)
        # Check the instance was created including the port.
        assert len(context.diagrams.blocks()) == 1
        assert len(context.diagrams.ports(1)) == 1
        # There should still be three items in the explorer (subprogram, port and diagram).
        assert context.explorer.count() == 3

        # Create a new block with a port and connect them
        context.diagrams.create_block(client.Block)
        context.diagrams.add_port(3, client.FlowPort)
        context.diagrams.connect((3, 0), (1, 0), client.FlowPortConnection)
        # Check there is a relationship representation in the diagram.
        assert len(context.diagrams.current_diagram().connections) == 1
        assert isinstance(context.diagrams.current_diagram().connections[0], modeled_shape.Relationship)
        check_expected_response()

    @test
    def test_other_shape():
        """ Test is a block with another shape than a rect of note is displayed properly.
            We test using the UseCase block, which is supposed to be represented with an ellipse.
        """
        # First create and open a UseCaseDiagram
        context = intergration_context(hierarchy=[
            client.UseCaseDiagram(Id=1, name="Requirements").asdict(),
        ])
        add_expected_response('/data/diagram_contents/1', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=1)
        context.diagrams.create_block(client.UseCase)
        # Check the shape is rendered using an ellipse, not a rect.
        shape = context.diagrams.current_diagram().children[0].shape
        assert shape.select('ellipse')
        check_expected_response()

    @test
    def load_subdiagram():
        """ Test loading a subdiagram from the API.
            This particular case has caused trouble in the past...
        """
        # Create a diagram with a block and load it from the database
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=5, name="Requirements").asdict(),
        ])
        data = '''[{"Id": 1, "diagram": 5, "block": 6, "parent": null, "x": 347.0, "y": 188.0, "z": 0.0, "width": 64.0, "height": 40.0, "order": 0, "orientation": null, "styling": "", "category": 2, "_entity": {"order": 0, "orientation": 4, "Id": 6, "name": "", "parent": 5, "__classname__": "FlowPort"}, "__classname__": "_BlockRepresentation"}, {"Id": 2, "diagram": 5, "block": 7, "parent": null, "x": 253.0, "y": 531.0, "z": 0.0, "width": 64.0, "height": 40.0, "order": 0, "orientation": null, "styling": "", "category": 2, "_entity": {"order": 0, "Id": 7, "description": "", "parent": 5, "__classname__": "Note"}, "__classname__": "_BlockRepresentation"}, {"Id": 1, "diagram": 5, "relationship": 1, "source_repr_id": 2, "target_repr_id": 1, "routing": "[]", "z": 0.0, "styling": {}, "__classname__": "_RelationshipRepresentation", "_entity": {"Id": 1, "source": 7, "target": 6, "name": "", "__classname__": "Anchor"}}]'''
        add_expected_response('/data/diagram_contents/5', 'get', Response(200, json=json.loads(data)))
        context.explorer.dblclick_element(mid=5)
        # Check the diagram is properly displayed
        diagram: ModeledDiagram = context.diagrams.current_diagram()
        assert len(diagram.children) == 2
        assert len(diagram.connections) == 1
        check_expected_response()

    @test
    def change_styling():
        """ Change the style of a block through the property editor, and check the block is updated. """
        # Create a diagram with a block and display it
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=5, name="Requirements").asdict(),
            client.FlowPort(Id=6, parent=5, orientation=4).asdict()
        ])
        data = {"Id": 1, "diagram": 5, "block": 6, "parent": None, "x": 347.0, "y": 188.0, "z": 0.0, "width": 64.0,
                "height": 40.0, "order": 0, "orientation": 4, "styling": "", "category": 2,
                "_entity": {"order": 0, "orientation": 4, "Id": 6, "name": "", "parent": 5,
                            "__classname__": "FlowPort"}, "__classname__": "_BlockRepresentation"}
        add_expected_response('/data/diagram_contents/5', 'get', Response(200, json=[data]))
        context.explorer.dblclick_element(mid=5)
        # Click the block so it is displayed in the properties editor.
        context.diagrams.click_block(rid=1)
        # Change the fill color for the block
        add_expected_response('/data/_BlockRepresentation/1', 'post', Response(200, []))
        # For now, we accept the FlowPort is updated as well. The current value for `orientation` isn't handled by the sim.
        add_expected_response('/data/FlowPort/6', 'post', Response(200, json={}))
        color = '#1A5FB4'  # A nice blue color that I REALLY want my block to have.
        context.property_editor.set_style(blockcolor=color)
        context.property_editor.save()
        # Check the block in the diagram has a different color now.
        shape = context.diagrams.blocks()[0].shape
        assert shape.select_one('polyline').style['fill'].upper() == color.upper()

        # Check the AJAX requests were consumed.
        check_expected_response()

    @test
    def add_element_in_explorer():
        context = intergration_context(hierarchy=[
            client.StructuralModel(Id=1, name='Structural Model').asdict()
        ])
        add_expected_response('/data/StructuralModel', 'post', Response(201, json={'Id': 2}))
        context.explorer.create_block(1, client.StructuralModel, name='testblock')
        # Check there is only one representation in the hierarchy
        assert len(context.explorer.find_elements(f'[data-modelid="2"] .ename')) == 1
        check_expected_response()

    @test
    def add_relationship():
        # Create a diagram with two blocks and display it
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=5, name="Requirements").asdict()
        ])
        data = [
            {"Id": 1, "diagram": 5, "block": 6, "parent": None, "x": 347.0, "y": 188.0, "z": 0.0, "width": 64.0,
             "height": 40.0, "order": 0, "orientation": 4, "styling": "", "category": 2,
             "__classname__": "_BlockRepresentation",
             "_entity": {
                 "order": 0, "Id": 6, "name": "A", "parent": 5, "__classname__": "Block"
             }
             },
            {
                "Id": 2, "diagram": 5, "block": 7, "parent": None, "x": 647.0, "y": 188.0, "z": 0.0, "width": 64.0,
                "height": 40.0, "order": 0, "styling": "", "category": 2,
                "__classname__": "_BlockRepresentation",
                "_entity": {
                    "order": 0, "Id": 7, "name": "A", "parent": 5, "__classname__": "Block"
                }
            }

        ]
        add_expected_response('/data/diagram_contents/5', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=5)
        # Connect the two blocks
        context.diagrams.connect(1, 2, client.BlockReference, expect_popup=True)

        # Check the connection is rendered with two lines, one being a transparant wide clickable line
        fg = context.diagrams.parent.select('path[data-class="ModeledRelationship"]')
        assert len(fg) == 1
        fg = fg[0]
        bg = context.diagrams.parent.select('path[opacity="0.0"]')
        assert len(bg) == 1
        bg = bg[0]
        assert fg != bg
        assert int(bg.attrs['stroke-width']) >= 10
        assert bg.subscribers['mousedown']
        # When the background is clicked, the line should be decorated with handles.
        assert len(context.diagrams.parent.select('.line_handle')) == 0
        bg.dispatchEvent(events.MouseDown())
        assert len(context.diagrams.parent.select('.line_handle')) > 0
        # We should be able to edit the start- and endmarkers in the properties editor
        context.property_editor.expect_request('/data/_RelationshipRepresentation/1', 'post', 200, response_json=None)
        context.property_editor.set_style(endmarker='square', startmarker='squareopen')
        context.property_editor.save()
        assert fg.attrs['marker-start'] == "url('#squareopen')"
        assert fg.attrs['marker-end'] == "url('#square')"
        check_expected_response()

    @test
    def add_block_delete():
        """ See if JSON with a faulty routing_method for the relationship loads successfully.
            Then, add a block to the diagram, and delete it again.
            Deleting a block in a diagram does not remove it from the model, this is done separately.
        """
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=3, name="Requirements").asdict()
        ])
        data = [
            {
                'Id': 2, 'diagram': 3, 'block': 4, 'parent': None, 'x': 383.0, 'y': 137.0, 'z': 0.0, 'width': 64.0,
                'height': 40.0, 'order': 0, 'orientation': None, 'styling': '{"blockcolor": "#fffbd6"}', 'category': 2,
                '_entity': {
                    'order': 0, 'Id': 4, 'name': 'Class', 'description': '',
                    'styling': {'shape': 'rect', 'bordercolor': '#000000', 'bordersize': '2', 'blockcolor': '#fffbd6',
                                'cornerradius': '0'}, 'parent': 3, '__classname__': 'Block'
                },
                '__classname__': '_BlockRepresentation'
            }, {
                'Id': 3, 'diagram': 3, 'block': 5, 'parent': None, 'x': 208.0, 'y': 362.0, 'z': 0.0, 'width': 118.0,
                'height': 40.0, 'order': 0, 'orientation': None, 'styling': '{"blockcolor": "#fffbd6"}', 'category': 2,
                '_entity': {
                    'order': 0, 'Id': 5, 'name': 'Inheritance',
                    'styling': {'shape': 'rect', 'bordercolor': '#000000', 'bordersize': '2', 'blockcolor': '#fffbd6',
                                'cornerradius': '0'}, 'parent': 3, '__classname__': 'Block'
                }, '__classname__': '_BlockRepresentation'
            }, {
                'Id': 1, 'diagram': 3, 'relationship': 1, 'source_repr_id': 2, 'target_repr_id': 3, 'routing': '[]',
                'z': 0.0, 'styling': {'endmarker': 'square', 'startmarker': 'hat', 'routing_method': ''},
                '__classname__': '_RelationshipRepresentation',
                '_entity': {'Id': 1, 'source': 4, 'target': 5, '__classname__': 'BlockGeneralization'}
            }
        ]
        add_expected_response('/data/diagram_contents/3', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=3)
        context.diagrams.create_block(client.Block)
        # Delete the representation
        context.diagrams.delete_block(rid=4)
        # Delete the underlying model item.
        context.explorer.delete_block(mid=6)
        assert context.no_dialogs()
        check_expected_response()

    @test
    def showing_and_hiding_handles():
        """ In a diagram, shapes and connections have 'decorators', the handles used to manipulate them.
            They are maintained by the diagram state machine, check these do their job correctly.
        """
        # Start with a diagram with three blocks and two connections.
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=3, name="Requirements").asdict()
        ])
        add_expected_response('/data/diagram_contents/3', 'get', Response(200, json=example_diagram))
        context.explorer.dblclick_element(mid=3)
        # Move a block (using drag & drop) and check it is decorated.
        context.diagrams.move_block(1, (100, 100))
        assert context.diagrams.nr_block_decorated() == 8
        # Click a second block
        context.diagrams.move_block(2, (100, 100))
        assert context.diagrams.nr_block_decorated() == 8
        # Switch to a different event handling FSM (should remove handles)
        context.diagrams.enter_connection_mode()
        assert context.diagrams.nr_block_decorated() == 0
        # Test switching between blocks and connections
        context.diagrams.enter_block_mode()
        context.diagrams.click_block(1)
        assert context.diagrams.nr_block_decorated() == 8
        context.diagrams.click_relation(1)
        assert context.diagrams.nr_block_decorated() == 1
        context.diagrams.click_block(2)
        assert context.diagrams.nr_block_decorated() == 8
        context.diagrams.click_relation(2)
        assert context.diagrams.nr_block_decorated() == 3
        context.diagrams.click_relation(1)
        assert context.diagrams.nr_block_decorated() == 1
        context.diagrams.enter_connection_mode()
        assert context.diagrams.nr_block_decorated() == 0

    @test
    def move_waypoints():
        data = [{"Id": 2, "diagram": 3, "block": 4, "parent": None, "x": 388.0, "y": 107.0, "z": 0.0, "width": 64.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2, "_entity": {"order": 0, "Id": 4, "name": "Class", "description": "",
                                            "styling": {"shape": "rect", "bordercolor": "#000000", "bordersize": "2",
                                                        "blockcolor": "#fffbd6", "cornerradius": "0"}, "parent": 3,
                                            "__classname__": "Block"}, "__classname__": "_BlockRepresentation"},
                {"Id": 3, "diagram": 3, "block": 5, "parent": None, "x": 244.0, "y": 247.0, "z": 0.0, "width": 118.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2, "_entity": {"order": 0, "Id": 5, "name": "Association",
                                            "styling": {"shape": "rect", "bordercolor": "#000000", "bordersize": "2",
                                                        "blockcolor": "#fffbd6", "cornerradius": "0"}, "parent": 3,
                                            "__classname__": "Block"}, "__classname__": "_BlockRepresentation"},
                {"Id": 4, "diagram": 3, "block": 6, "parent": None, "x": 253.0, "y": 350.0, "z": 0.0, "width": 98.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2,
                 "_entity": {"order": 0, "Id": 6, "name": "stereotype", "parent": 3, "__classname__": "Block"},
                 "__classname__": "_BlockRepresentation"},
                {"Id": 5, "diagram": 3, "block": 7, "parent": None, "x": 156.0, "y": 446.0, "z": 0.0, "width": 108.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2,
                 "_entity": {"order": 0, "Id": 7, "name": "Inheritance", "parent": 3, "__classname__": "Block"},
                 "__classname__": "_BlockRepresentation"},
                {"Id": 6, "diagram": 3, "block": 8, "parent": None, "x": 157.0, "y": 506.0, "z": 0.0, "width": 113.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2,
                 "_entity": {"order": 0, "Id": 8, "name": "Composite", "parent": 3, "__classname__": "Block"},
                 "__classname__": "_BlockRepresentation"},
                {"Id": 7, "diagram": 3, "block": 9, "parent": None, "x": 159.0, "y": 566.0, "z": 0.0, "width": 112.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2,
                 "_entity": {"order": 0, "Id": 9, "name": "Aggregate", "parent": 3, "__classname__": "Block"},
                 "__classname__": "_BlockRepresentation"},
                {"Id": 8, "diagram": 3, "block": 10, "parent": None, "x": 161.0, "y": 628.0, "z": 0.0, "width": 114.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2,
                 "_entity": {"order": 0, "Id": 10, "name": "Association", "parent": 3, "__classname__": "Block"},
                 "__classname__": "_BlockRepresentation"},
                {"Id": 13, "diagram": 3, "block": 15, "parent": None, "x": 597.0, "y": 227.0, "z": 0.0, "width": 64.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2, "_entity": {"order": 0, "Id": 15, "name": "Class Diagram", "type": 1, "parent": 3,
                                            "__classname__": "Block"}, "__classname__": "_BlockRepresentation"},
                {"Id": 14, "diagram": 3, "block": 16, "parent": None, "x": 475.0, "y": 420.0, "z": 0.0, "width": 64.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2,
                 "_entity": {"order": 0, "Id": 16, "name": "name", "type": 2, "parent": 3, "__classname__": "Block"},
                 "__classname__": "_BlockRepresentation"},
                {"Id": 15, "diagram": 3, "block": 17, "parent": None, "x": 478.0, "y": 498.0, "z": 0.0, "width": 109.0,
                 "height": 40.0, "order": 0, "orientation": None, "styling": "{\"blockcolor\": \"#fffbd6\"}",
                 "category": 2, "_entity": {"order": 0, "Id": 17, "name": "description", "type": 3, "parent": 3,
                                            "__classname__": "Block"}, "__classname__": "_BlockRepresentation"},
                {"Id": 1, "diagram": 3, "relationship": 1, "source_repr_id": 2, "target_repr_id": 3,
                 "routing": "[[401.0, Infinity]]", "z": 0.0,
                 "styling": {"endmarker": "hat", "startmarker": "hat", "routing_method": "square"},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 1, "source": 4, "target": 5, "__classname__": "BlockGeneralization"}},
                {"Id": 2, "diagram": 3, "relationship": 2, "source_repr_id": 3, "target_repr_id": 4, "routing": "[]",
                 "z": 0.0, "styling": {}, "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 2, "parent": 3, "source": 5, "target": 6, "__classname__": "BlockGeneralization"}},
                {"Id": 3, "diagram": 3, "relationship": 3, "source_repr_id": 4, "target_repr_id": 5, "routing": "[]",
                 "z": 0.0, "styling": {}, "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 3, "parent": 3, "source": 6, "target": 7, "__classname__": "BlockGeneralization"}},
                {"Id": 4, "diagram": 3, "relationship": 4, "source_repr_id": 4, "target_repr_id": 6,
                 "routing": "[[201.5, Infinity]]", "z": 0.0, "styling": {},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 4, "parent": 3, "source": 6, "target": 8, "__classname__": "BlockGeneralization"}},
                {"Id": 5, "diagram": 3, "relationship": 5, "source_repr_id": 4, "target_repr_id": 7,
                 "routing": "[[226.5, Infinity]]", "z": 0.0, "styling": {},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 5, "parent": 3, "source": 6, "target": 9, "__classname__": "BlockGeneralization"}},
                {"Id": 6, "diagram": 3, "relationship": 6, "source_repr_id": 4, "target_repr_id": 8,
                 "routing": "[[248.5, Infinity]]", "z": 0.0, "styling": {},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 6, "parent": 3, "source": 6, "target": 10, "__classname__": "BlockGeneralization"}},
                {"Id": 7, "diagram": 3, "relationship": 7, "source_repr_id": 2, "target_repr_id": 13, "routing": "[]",
                 "z": 0.0, "styling": {}, "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 7, "parent": 3, "source": 4, "target": 15, "__classname__": "BlockGeneralization"}},
                {"Id": 8, "diagram": 3, "relationship": 8, "source_repr_id": 13, "target_repr_id": 14, "routing": "[]",
                 "z": 0.0, "styling": {}, "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 8, "parent": 3, "source": 15, "target": 16, "__classname__": "BlockGeneralization"}},
                {"Id": 9, "diagram": 3, "relationship": 9, "source_repr_id": 2, "target_repr_id": 14,
                 "routing": "[[437.0, Infinity]]", "z": 0.0, "styling": {},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 9, "parent": 3, "source": 4, "target": 16, "__classname__": "BlockGeneralization"}},
                {"Id": 10, "diagram": 3, "relationship": 10, "source_repr_id": 13, "target_repr_id": 15,
                 "routing": "[[649.0, Infinity], [Infinity, 372.0], [556.5, Infinity]]", "z": 0.0, "styling": {},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 10, "parent": 3, "source": 15, "target": 17,
                             "__classname__": "BlockGeneralization"}},
                {"Id": 11, "diagram": 3, "relationship": 11, "source_repr_id": 2, "target_repr_id": 15,
                 "routing": "[[Infinity, 518.5]]", "z": 0.0, "styling": {},
                 "__classname__": "_RelationshipRepresentation",
                 "_entity": {"Id": 11, "parent": 3, "source": 4, "target": 17, "__classname__": "BlockGeneralization"}}]
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=3, name="Requirements").asdict()
        ])
        add_expected_response('/data/diagram_contents/3', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=3)

        # Try to re-route the link between _Entity 6 and _Entity 10 (_Relationship 6, RelationRepresentation 6),
        context.diagrams.click_relation(6)
        # Take the second handle of the relationship and drag it left 100 places
        add_expected_response('/data/_RelationshipRepresentation/6', 'post', Response(200, json=data))
        context.diagrams.drag_relation_handle(1, (100, 0))
        check_expected_response()

    @test
    def test_RingedClosedCircle():
        """ The styling of the shape "test_RingedClosedCircle" was troublesome, thus this specific test.
            Its fill color switched from 'none' to the default yellow when dragged.
        """
        context = intergration_context(hierarchy=[client.BlockDefinitionDiagram(Id=3).asdict()])
        add_expected_response('/data/diagram_contents/3', 'get', Response(
            200,
            json=[]))
        context.explorer.dblclick_element(mid=3)
        context.diagrams.create_block(client.EndState)
        block = context.diagrams.blocks()[0]
        assert block.getStyle('blockcolor') == '#ffffff'
        assert block.shape.children[0].children[1].attrs['fill'] == 'none'

        # Now move the block, and check the details are the same.
        context.diagrams.move_block(rid=1, cood=(100, 100))
        assert block.getStyle('blockcolor') == '#ffffff'
        assert block.shape.children[0].children[1].attrs['fill'] == 'none'

    @test
    def add_move_delete_message():
        """ Test for adding a message to a relationship, as in a communication diagram. """
        context = intergration_context(hierarchy=[client.BlockDefinitionDiagram(Id=3).asdict()])
        # Two blocks connected with a block reference
        s = client.Block(Id=4)
        t = client.Block(Id=5)
        add_expected_response('/data/diagram_contents/3', 'get', Response(
            200,
            json=[
                {'Id': 2, 'diagram': 3, 'block': 4, 'parent': None, 'x': 383.0, 'y': 137.0, 'width': 64.0,
                 'height': 40.0, 'category': 2, '__classname__': '_BlockRepresentation',
                 '_entity': s.asdict()},
                {'Id': 3, 'diagram': 3, 'block': 5, 'parent': None, 'x': 383.0, 'y': 137.0, 'width': 64.0,
                 'height': 40.0, 'category': 2, '__classname__': '_BlockRepresentation',
                 '_entity': t.asdict()},
                {'Id': 1, 'diagram': 3, 'relationship': 1, 'source_repr_id': 2, 'target_repr_id': 3, 'routing': '[]',
                 '__classname__': '_RelationshipRepresentation',
                 '_entity': client.BlockReference(Id=1, source=s, target=t).asdict()}
            ]))
        context.explorer.dblclick_element(mid=3)
        context.diagrams.create_message(rid=1, cls=client.ClassMessage)
        msgs = context.data_store.live_instances[Collection.message]
        assert len(msgs) == 1
        msg_reprs = context.data_store.live_instances[Collection.message_repr]
        assert len(msg_reprs) == 1
        assert msgs[1].association == 1

        # Try moving it
        pos = msg_reprs[1].getPos()
        context.diagrams.move_message(rid=1, delta=(100, 100))
        assert msg_reprs[1].getPos() - pos == Point(100, 100)

        # Try deleting it
        context.diagrams.delete_message(rid=1)

    @test
    def display_message():
        context = intergration_context(hierarchy=[client.BlockDefinitionDiagram(Id=13).asdict()])
        data = [{
            "Id": 6, "diagram": 13, "block": 14, "parent": None, "x": 171.0, "y": 293.0, "z": 0.0, "width": 64.0,
            "height": 40.0, "order": None, "orientation": None, "styling": "", "category": 2,
            "_entity": {"order": 0, "parameters": {}, "Id": 14, "name": "", "parent": 13, "definition": 11,
                        "__classname__": "Block"},
            "_definition": None,
            "__classname__": "_BlockRepresentation"
        }, {
            "Id": 7, "diagram": 13, "block": 15, "parent": None, "x": 370.0, "y": 294.0, "z": 0.0, "width": 64.0,
            "height": 40.0, "order": None, "orientation": None, "styling": "", "category": 2,
            "_entity": {"order": 0, "parameters": {}, "Id": 15, "name": "", "parent": 13, "definition": 12,
                        "__classname__": "Block"},
            "_definition": None,
            "__classname__": "_BlockRepresentation"
        }, {
            "Id": 3, "diagram": 13, "relationship": 3, "source_repr_id": 6, "target_repr_id": 7, "routing": "[]",
            "z": 0.0, "styling": {}, "__classname__": "_RelationshipRepresentation",
            "_entity": {"Id": 3, "parent": 13, "source": 14, "target": 15, "__classname__": "BlockReference"}
        }, {
            "Id": 1, "diagram": 13, "message": 17, "parent": 3, "x": 235.0, "y": 313.5, "z": 0.0, "order": 0,
            "orientation": 0.0, "direction": 1, "styling": {},
            "__classname__": "_MessageRepresentation",
            "_entity": {"order": 0, "Id": 17, "name": "test", "kind": 1, "arguments": "", "description": "",
                        "parent": 13, "association": 3, "__classname__": "ClassMessage"}
        }]
        add_expected_response('/data/diagram_contents/13', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=13)

        # Check the message is rendered.
        canvas = context.diagrams.parent
        msgs = canvas.select(f'g[data-category="5"]')
        assert len(msgs) == 1
        msg = msgs[0]
        assert msg.attrs['data-rid'] == 1
        assert msg.attrs['data-mid'] == 17

    @test
    def undo_redo():
        context = intergration_context(hierarchy=[
            client.BlockDefinitionDiagram(Id=13).asdict(),
            client.Block(Id=14, parent=13, name='Test Block').asdict(),
            client.FlowPort(Id=15, parent=14, name='Output').asdict()
        ])
        add_expected_response('/data/diagram_contents/13', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=13)
        # There should be two blocks and one port in the model, no representations.
        assert len(list(context.ds.all_elements())) == 3
        # Add a block with ports through dag-and-drop
        brid1 = context.explorer.drag_to_diagram(mid=14, drop_cls=client.Block)
        # Add a block by creating a new one
        _, brid2 = context.diagrams.create_block(client.Block)
        # Add a port to the new block
        context.diagrams.add_port(brid2, client.FlowPort)
        # Connect the blocks
        _, cid = context.diagrams.connect((brid1, 0), (brid2, 0), client.FlowPortConnection)
        # Gather the IDs of the blocks, ports and connection
        # There should be 1 diagram, 2 blocks, 2 ports, 1 connection, and 4 block reprs + 1 connection repr
        assert len(list(context.ds.all_elements())) == 6 + 5  # model items + representations
        assert len(context.ds.undo_queue) == 4
        assert len(context.ds.redo_queue) == 0
        # Undo adding the connection
        add_expected_response('/data/FlowPortConnection/1', 'delete', Response(204, json=[]))
        add_expected_response('/data/_RelationshipRepresentation/1', 'delete', Response(204, json=[]))
        context.diagrams.undo()
        check_expected_response()
        assert len(list(context.ds.all_elements())) == 5 + 4  # model items + representations

        add_expected_response('/data/FlowPort/17', 'delete', Response(204, json=[]))
        add_expected_response('/data/_BlockRepresentation/4', 'delete', Response(204, json=[]))
        context.diagrams.undo()
        check_expected_response()

        add_expected_response('/data/_BlockRepresentation/3', 'delete', Response(204, json=[]))
        add_expected_response('/data/Block/16', 'delete', Response(204, json=[]))
        context.diagrams.undo()
        check_expected_response()

        add_expected_response('/data/_BlockRepresentation/2', 'delete', Response(204, json=[]))
        add_expected_response('/data/_BlockRepresentation/1', 'delete', Response(204, json=[]))
        context.diagrams.undo()
        check_expected_response()

        # Check all these IDs are gone from the data store
        # There should be two block and one port in the model, no representations.
        assert len(list(context.ds.all_elements())) == 3
        assert len(context.ds.undo_queue) == 0
        assert len(context.ds.redo_queue) == 4
        # Redo all these acts

        add_expected_response('/data/_BlockRepresentation', 'post', Response(201, json={'Id': 2}))
        add_expected_response('/data/_BlockRepresentation', 'post', Response(201, json={'Id': 1}))
        context.diagrams.redo()
        check_expected_response()

        add_expected_response('/data/_BlockRepresentation', 'post', Response(201, json={'Id': 3}))
        add_expected_response('/data/Block', 'post', Response(201, json={'Id': 16}))
        context.diagrams.redo()
        check_expected_response()

        add_expected_response('/data/FlowPort', 'post', Response(201, json={'Id': 17}))
        add_expected_response('/data/_BlockRepresentation', 'post', Response(201, json={'Id': 4}))
        context.diagrams.redo()
        check_expected_response()

        add_expected_response('/data/FlowPortConnection', 'post', Response(201, json={'Id': 1}))
        add_expected_response('/data/_RelationshipRepresentation', 'post', Response(201, json={'Id': 1}))
        context.diagrams.redo()
        check_expected_response()


        # Check all these IDs are back in the data store
        # There should be 1 diagram, 2 blocks, 2 ports, 1 connection, and 4 block reprs + 1 connection repr
        assert len(list(context.ds.all_elements())) == 6 + 5  # model items + representations
        assert len(context.ds.undo_queue) == 4
        assert len(context.ds.redo_queue) == 0

        # Now try to undo a delete.
        # Delete a port, which should also delete the connection.
        add_expected_response('/data/FlowPort/17', 'delete', Response(204, json=[]))
        add_expected_response('/data/_BlockRepresentation/4', 'delete', Response(204, json=[]))
        add_expected_response('/data/FlowPortConnection/1', 'delete', Response(204, json=[]))
        add_expected_response('/data/_RelationshipRepresentation/1', 'delete', Response(204, json=[]))

        context.data_store.delete(context.data_store.get(Collection.block, 17))
        check_expected_response()

        add_expected_response('/data/FlowPort', 'post', Response(201, json={'Id': 17}))
        add_expected_response('/data/_BlockRepresentation', 'post', Response(201, json={'Id': 4}))
        add_expected_response('/data/FlowPortConnection', 'post', Response(201, json={'Id': 1}))
        add_expected_response('/data/_RelationshipRepresentation', 'post', Response(201, json={'Id': 1}))

        context.diagrams.undo()
        check_expected_response()

        add_expected_response('/data/FlowPort/17', 'delete', Response(204, json=[]))
        add_expected_response('/data/_BlockRepresentation/4', 'delete', Response(204, json=[]))
        add_expected_response('/data/FlowPortConnection/1', 'delete', Response(204, json=[]))
        add_expected_response('/data/_RelationshipRepresentation/1', 'delete', Response(204, json=[]))

        context.diagrams.redo()
        check_expected_response()

    @test
    def multi_select():
        # Create a diagram with multiple blocks: try to select and move them together.
        # Create a diagram with two blocks and display it
        context = intergration_context(hierarchy=[
            client.SubProgramDefinition(Id=5, name="Requirements").asdict()
        ])
        data = [
            {"Id": 1, "diagram": 5, "block": 6, "parent": None, "x": 347.0, "y": 188.0, "z": 0.0, "width": 64.0,
             "height": 40.0, "order": 0, "orientation": 4, "styling": "", "category": 2,
             "__classname__": "_BlockRepresentation",
             "_entity": {
                 "order": 0, "Id": 6, "name": "A", "parent": 5, "__classname__": "Block"
             }
             },
            {
                "Id": 2, "diagram": 5, "block": 7, "parent": None, "x": 647.0, "y": 188.0, "z": 0.0, "width": 64.0,
                "height": 40.0, "order": 0, "styling": "", "category": 2,
                "__classname__": "_BlockRepresentation",
                "_entity": {
                    "order": 0, "Id": 7, "name": "A", "parent": 5, "__classname__": "Block"
                }
            }

        ]
        add_expected_response('/data/diagram_contents/5', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=5)

        # Select both blocks
        context.diagrams.click_block(1)
        context.diagrams.click_block(2, ctrlKey=True)
        # Drag one block for 100 pixels
        # The move function expects a change for #1. Add one for #2.
        add_expected_response('/data/_BlockRepresentation/2', 'post', Response(200, json=None))
        context.diagrams.move_block(1, [100.0, 0.0])
        # Check both were moved.
        assert context.data_store.live_instances[Collection.block_repr][1].getPos().x == data[0]['x']+100.0
        assert context.data_store.live_instances[Collection.block_repr][2].getPos().x == data[1]['x']+100.0
        check_expected_response()

    @test
    def laned_diagram():
        # Start with a system where there are two classes with a connection.
        context = intergration_context(hierarchy=[
            client.FunctionalModel(Id=1).asdict(),
            client.StructuralModel(Id=2).asdict(),
            client.Class(Id=10, parent=2, name='A').asdict(),
            client.Class(Id=11, parent=2, name='B').asdict(),
            client.SequenceDiagram(Id=20, parent=1).asdict()
        ])
        # Create a sequence diagram
        add_expected_response('/data/diagram_contents/20', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=20)

        # Instantiate two blocks in the diagram
        context.explorer.drag_to_diagram(10, client.ObjectSequenceInstance)
        context.explorer.drag_to_diagram(10, client.ObjectSequenceInstance)

        assert len(context.diagrams.blocks()) == 2
        for shape in context.diagrams.blocks():
            assert isinstance(shape, client.LanedShape)

        # Draw a message between the two blocks
        context.diagrams.connect(1, 2, client.SequencedMessage)
        assert len(context.diagrams.connections()) == 1
        c = context.diagrams.connections()[0]
        assert c.default_style['routing_method'] == 'sequence_msg'
        assert c.category == ReprCategory.laned_connection
        assert c.waypoints == [Point(30,30)]

        # Draw another message between the two block
        context.diagrams.connect(1, 2, client.SequencedMessage)
        assert len(context.diagrams.connections()) == 2
        c = context.diagrams.connections()[1]
        assert c.default_style['routing_method'] == 'sequence_msg'
        assert c.category == ReprCategory.laned_connection
        assert c.waypoints == [Point(60,60)]
        check_expected_response()

        # Drag the second message down
        # TODO: I am not sure if this call should be there, but I'll let it go for now.
        add_expected_response('/data/_RelationshipRepresentation/2', 'post', Response(200, json=[]),
                              expect_values={'routing': '[[60.0, 60.0]]'})
        context.diagrams.click_relation(2)
        check_expected_response()
        add_expected_response('/data/_RelationshipRepresentation/2', 'post', Response(200, json=[]),
                              expect_values={'routing': '[[100.0, 100.0]]'})
        context.diagrams.drag_relation_handle(0, (0, 40))
        assert c.waypoints == [Point(100,100)]
        check_expected_response()

        # Drag the first block to the right, at some point it should jump over the second block.
        b1, b2 = context.diagrams.blocks()
        p1 = copy(b1.getPos())
        p2 = copy(b2.getPos())
        d_x = p2.x - p1.x
        # First move it half-way across
        # Currently, the clipping of the block happens after the initial change was sent to the database.
        # So two changes are expected.
        add_expected_response('/data/_BlockRepresentation/1', 'post', Response(200, json=[]))
        add_expected_response('/data/_BlockRepresentation/2', 'post', Response(200, json=[]))
        context.diagrams.move_block(b1.Id, [d_x//2,0], expect_no_change=True)
        # The block should be back at the correct position
        assert b1.getPos() == Point(90,60)
        assert b2.getPos() == Point(174,60)
        # Now move it over the other block. The blocks should be swapped.
        add_expected_response('/data/_BlockRepresentation/2', 'post', Response(200, json=[]))
        context.diagrams.move_block(b1.Id, [d_x+10, 0])
        assert b1.getPos() == Point(174,60)
        assert b2.getPos() == Point(90,60)


        # Draw a message-to-self on the second block
        context.diagrams.connect(2, 2, client.SequencedMessage)
        assert len(context.diagrams.connections()) == 3
        check_expected_response()
        c3 = context.diagrams.connections()[2]
        assert re.match(r"M \d+ \d+ h \d+ v \d+ h -\d+", c3.path.attrs['d'])


    @test
    def load_laned_diagram():
        json_data = """[{"Id": 37, "diagram": 45, "block": 55, "parent": null, "x": 95.0, "y": 60.0, "z": 0.0, "width": 40.0, "height": 64.0, "order": 0, "orientation": null, "styling": "", "category": 6, "lane_length": 1000.0, "_entity": {"order": 0, "Id": 55, "name": "", "description": "", "parent": 45, "__classname__": "Actor"}, "__classname__": "_BlockRepresentation"}, {"Id": 38, "diagram": 45, "block": 56, "parent": null, "x": 195.0, "y": 54.0, "z": 0.0, "width": 40.0, "height": 64.0, "order": 0, "orientation": null, "styling": "", "category": 6, "lane_length": 1000.0, "_entity": {"order": 0, "Id": 56, "name": "", "description": "", "parent": 45, "__classname__": "Actor"}, "__classname__": "_BlockRepresentation"}, {"Id": 34, "diagram": 45, "relationship": 34, "source_repr_id": 37, "target_repr_id": 38, "routing": "[[45.0, 45.0]]", "z": 0.0, "styling": {}, "category": 7, "__classname__": "_RelationshipRepresentation", "_entity": {"Id": 34, "source": 55, "target": 56, "name": "", "kind": 1, "parent": 45, "__classname__": "SequencedMessage"}}, {"Id": 35, "diagram": 45, "relationship": 35, "source_repr_id": 37, "target_repr_id": 38, "routing": "[[90.0, 90.0]]", "z": 0.0, "styling": {}, "category": 7, "__classname__": "_RelationshipRepresentation", "_entity": {"Id": 35, "source": 55, "target": 56, "name": "", "kind": 1, "parent": 45, "__classname__": "SequencedMessage"}}]"""
        data = json.loads(json_data)
        context = intergration_context(hierarchy=[
            client.FunctionalModel(Id=1).asdict(),
            client.StructuralModel(Id=2).asdict(),
            client.Actor(Id=55, parent=45, name='A').asdict(),
            client.Actor(Id=56, parent=45, name='B').asdict(),
            client.SequenceDiagram(Id=45, parent=1).asdict()
        ])
        # Open the sequence diagram
        add_expected_response('/data/diagram_contents/45', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=45)

        assert len(context.diagrams.connections()) == 2
        c1, c2 = context.diagrams.connections()
        assert c1.waypoints == [Point(45,45)]
        assert c2.waypoints == [Point(90,90)]
        check_expected_response()

    @test
    def laned_diagram_with_msg_text():
        json_data = """[{"Id": 37, "diagram": 45, "block": 55, "parent": null, "x": 161.0, "y": 96.0, "z": 0.0, "width": 42.0, "height": 64.0, "order": 2, "orientation": null, "styling": "", "category": 6, "lane_length": 1000.0, "_entity": {"order": 0, "Id": 55, "name": "", "description": "", "parent": 45, "__classname__": "Actor"}, "__classname__": "_BlockRepresentation"}, {"Id": 38, "diagram": 45, "block": 56, "parent": null, "x": 90.0, "y": 99.0, "z": 0.0, "width": 51.0, "height": 64.0, "order": 1, "orientation": null, "styling": "", "category": 6, "lane_length": 1000.0, "_entity": {"order": 0, "Id": 56, "name": "", "description": "", "parent": 45, "__classname__": "Actor"}, "__classname__": "_BlockRepresentation"}, {"Id": 34, "diagram": 45, "relationship": 34, "source_repr_id": 37, "target_repr_id": 38, "routing": "[[50.0, 50.0]]", "z": 0.0, "styling": {}, "category": 7, "__classname__": "_RelationshipRepresentation", "_entity": {"Id": 34, "source": 55, "target": 56, "name": "answer", "kind": 1, "parent": 45, "__classname__": "SequencedMessage"}}, {"Id": 35, "diagram": 45, "relationship": 35, "source_repr_id": 37, "target_repr_id": 38, "routing": "[[13.0, 13.0]]", "z": 0.0, "styling": {}, "category": 7, "__classname__": "_RelationshipRepresentation", "_entity": {"Id": 35, "source": 55, "target": 56, "name": "Request", "kind": 1, "parent": 45, "__classname__": "SequencedMessage"}}, {"Id": 36, "diagram": 45, "relationship": 36, "source_repr_id": 37, "target_repr_id": 37, "routing": "[[80.0, 80.0]]", "z": 0.0, "styling": {}, "anchor_offsets": {"C": [20.0, 30.0]}, "anchor_sizes": {"C": [80.0,20.0]}, "category": 7, "__classname__": "_RelationshipRepresentation", "_entity": {"Id": 36, "source": 55, "target": 55, "name": "Dit is een TEST", "kind": 1, "parent": 45, "__classname__": "SequencedMessage"}}]"""
        data = json.loads(json_data)
        context = intergration_context(hierarchy=[
            client.FunctionalModel(Id=1).asdict(),
            client.StructuralModel(Id=2).asdict(),
            client.SequenceDiagram(Id=45, parent=1).asdict()
        ])
        # Open the sequence diagram
        add_expected_response('/data/diagram_contents/45', 'get', Response(200, json=data))
        context.explorer.dblclick_element(mid=45)

        # Check the message names are rendered
        tag = [t for t in context.diagrams.parent.select('text') if t.text == 'Dit is een'][0]
        assert len(tag.parent.children) == 2
        assert tag.parent.children[1].text == 'TEST'

        # Try to drag a TextBox
        connection = context.diagrams.current_diagram().connections[2]
        tb = connection.text_widgets['C']
        p1 = tb.getPos()
        assert p1 == Point(20.0, 30.0) + context.diagrams.current_diagram().connections[2].previous_anchor_positions['C']
        add_expected_response('/data/_RelationshipRepresentation/36', 'post', Response(200, json={}))
        context.diagrams.move_shape(tb.shape.children[0], Point(20, 20))
        check_expected_response()
        p2 = tb.getPos()
        assert p2 - p1 == Point(20,20)

        # Check the new position is stored in the data
        data = context.diagrams.current_diagram().connections[2].asdict()
        assert data['anchor_offsets'] == {'C': (40.0, 50.0)}
        assert data['anchor_sizes'] == {'C': (80.0, 20.0)}

    @test
    def drag_and_drop_instance_with_ports():
        context = intergration_context(hierarchy=[
            o.asdict() for o in [
                client.FunctionalModel(Id=1),
                client.StructuralModel(Id=2),
                client.SubProgramDefinition(Id=3, parent=2, parameters={'name': 'str'}),
                client.FlowPort(Id=4, parent=3),
                client.FlowPort(Id=5, parent=3),
                client.BlockDefinitionDiagram(Id=45, parent=2)
            ]
        ])
        # Open the BlockDefinition diagram
        add_expected_response('/data/diagram_contents/45', 'get', Response(200, json=[]))
        context.explorer.dblclick_element(mid=45)
        # Drag and drop the SubProgram into the diagram.
        context.explorer.drag_to_diagram(3, client.BlockInstance)

        # Check that the ports have been created as well.
        assert len(context.diagrams.ports(1)) == 2
        # No new Block should be created, only a representation.
        assert len(context.data_store.live_instances[Collection.block]) == 3
        assert len(context.data_store.live_instances[Collection.block_repr]) == 3

        # Open the details editor
        context.diagrams.click_block(1)

if __name__ == '__main__':
    # import cProfile
    run_tests('*.add_relationship')
    run_tests()
    # cProfile.run('run_tests()', sort='tottime')
